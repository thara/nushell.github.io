<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="Deutsch">
  <id>www.nushell.sh/de/</id>
  <title>Nushell</title>
  <subtitle>Eine neue Art von Shell.</subtitle>
  <updated>2022-06-03T13:51:58.310Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="www.nushell.sh/feed.atom"/>
  <link rel="alternate" href="www.nushell.sh/de/"/>
  <entry>
    <title type="html">Konfiguration von Drittanbieter-Prompts</title>
    <id>www.nushell.sh/de/book/3rdpartyprompts.html</id>
    <link href="www.nushell.sh/de/book/3rdpartyprompts.html"/>
    <updated>2022-06-03T13:51:58.407Z</updated>
    <content type="html"><![CDATA[<h1 id="konfiguration-von-drittanbieter-prompts" tabindex="-1"> Konfiguration von Drittanbieter-Prompts</h1>
<h2 id="nerdfonts" tabindex="-1"> nerdfonts</h2>
<p>nerdfonts sind nicht zwangsweise notwendig, machen aber die Darstellung viel besser.
Sie enthalten unter anderem Symbole fÃ¼r Betriebssysteme oder den Git-Status und graphische Formen fÃ¼r einen ansprechenden Prompt.</p>
<p><a href="https://www.nerdfonts.com" target="_blank" rel="noopener noreferrer">Webseite</a></p>
<p><a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener noreferrer">Repository</a></p>
<h2 id="oh-my-posh" tabindex="-1"> oh-my-posh</h2>
<p><a href="https://ohmyposh.dev/" target="_blank" rel="noopener noreferrer">Webseite</a></p>
<p><a href="https://github.com/JanDeDobbeleer/oh-my-posh" target="_blank" rel="noopener noreferrer">Repository</a></p>
<p>Wenn <a href="https://ohmyposh.dev/" target="_blank" rel="noopener noreferrer">oh-my-posh</a> verwendet werden soll, kann dies in wenigen Schritten fÃ¼r Nushell erreicht werden. Die Integration in Nushell funktioniert sehr gut. Die folgenden Schritte werden dazu benÃ¶tigt:</p>
<ol>
<li>oh-my-posh installieren und die Farbschemata herunterladen entsprechend dieser <a href="https://ohmyposh.dev/docs/linux#installation" target="_blank" rel="noopener noreferrer">Anleitung</a></li>
<li>Herunterladen und installieren einer <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener noreferrer">nerd font</a>.</li>
<li>Die Umgebungsvariable <code>PROMPT_COMMAND</code> durch hinzufÃ¼gen der folgenden Zeile in <code>~/.config/nushell/config.nu</code> setzen. Den Style <code>M365Princess.omp.json</code> kann man entsprechend der <a href="https://ohmyposh.dev/docs/themes" target="_blank" rel="noopener noreferrer">Demo</a> beliebig Ã¤ndern .</li>
</ol>
<div><pre><code><span>></span> let-env PROMPT_COMMAND <span>=</span> <span>{</span> oh-my-posh --config ~/.poshthemes/M365Princess.omp.json <span>}</span>
</code></pre></div><h2 id="starship" tabindex="-1"> Starship</h2>
<p><a href="https://starship.rs/" target="_blank" rel="noopener noreferrer">Website</a></p>
<p><a href="https://github.com/starship/starship" target="_blank" rel="noopener noreferrer">Repository</a></p>
<ol>
<li>Den obigen Links folgen und starship installieren.</li>
<li>nerdfonts entsprechend persÃ¶nlicher PrÃ¤ferenzen installieren.</li>
<li>Die <code>STARSHIP_SHELL</code> Umgebungsvariable auf <code>nu</code> setzen, indem der folgende Befehl ausgefÃ¼hrt wird: <code>let-env STARSHIP_SHELL = &quot;nu&quot;</code></li>
<li>Wenn die standardmÃ¤ÃŸige Uhr mit Zeit und Datum auf der rechten Seite dargestellt werden soll, sollte der folgende Befehl ausgefÃ¼hrt werden: <code>hide PROMPT_COMMAND_RIGHT</code></li>
<li>Wenn der standardmÃ¤ÃŸige Indikator verwendet werden soll, kann der folgende Befehl ausgefÃ¼hrt werden: <code>let-env PROMPT_INDICATOR = &quot; &quot;</code></li>
<li>starship kann als Prompt auf der linken Seite mit dem folgenden Befehl festgelegt werden: <code>let-env PROMPT_COMMAND = { starship prompt --cmd-duration $env.CMD_DURATION_MS $'--status=($env.LAST_EXIT_CODE)' | str trim }</code>. Ein Hinweis: Unter UmstÃ¤nden muss <code>str trim</code> in der Nushell-Prompt nicht verwendet werden, wenn starship's standardmÃ¤ÃŸig aktive Einstellung fÃ¼r neue Zeilen in der <code>starship.toml</code> mittels <code>add_newline = false</code> deaktiviert wurde. Es gibt Berichte, dass dies teilweise nicht gut im Zusammenspiel mit Nushell-Prompts funktioniert. Wir arbeiten noch daran!</li>
<li>Da Nushell Prompts auf der rechten Seite unterstÃ¼tzt, kann auch mit starship's MÃ¶glichkeit einer solchen Prompt experimentiert werden. Die rechte Prompt in Nushell zu setzen funktioniert identisch, wie das Setzen der Linken. Es muss lediglich <code>PROMPT_COMMAND_RIGHT</code> gesetzt werden.</li>
</ol>
<h2 id="purs" tabindex="-1"> Purs</h2>
<p><a href="https://github.com/xcambar/purs" target="_blank" rel="noopener noreferrer">Repository</a></p>
]]></content>
  </entry>
  <entry>
    <title type="html">EinfÃ¼hrung</title>
    <id>www.nushell.sh/de/book/</id>
    <link href="www.nushell.sh/de/book/"/>
    <updated>2022-06-03T13:51:58.407Z</updated>
    <content type="html"><![CDATA[<h1 id="einfuhrung" tabindex="-1"> EinfÃ¼hrung</h1>
<p>Hallo und herzlich Willkommen beim Nushell Projekt. Das Ziel diese Projekts ist es, die Philosophie von Unix Shells, wo Pipes einfache Befehle miteinander verbinden, mit modernen AnsÃ¤tzen zu verbinden.</p>
<p>Nu ist von vielen Seiten beeinflusst: traditionelle Shells wie Bash, objektbasierte Shells wie PowerShell, funktionale Programmierung, Systems Programming und viele Weitere. Aber statt die eierlegende Wollmilchsau zu sein, liegt der Fokus von Nu darauf, die angebotenen Funktionen gut zu beherrschen:</p>
<ul>
<li>Flexible cross-plattform Shell mit einem modernen Verhalten</li>
<li>Ausgaben von Kommandozeilenprogrammen mit einer Shell zu verarbeiten, die Struktur von Daten versteht</li>
<li>Ein Interface besitzen, das den modernen BedÃ¼rfnissen gerecht wird</li>
</ul>
<p>Der einfachste Weg zu verstehen, was Nu alles leisten kann, ist entlang von Beispielen. Los geht's!</p>
<p>Das Erste was auffÃ¤llt, wenn ein Befehl wie <code>ls</code> ausgefÃ¼hrt wird, ist, dass anstatt eines Blocks von Text eine strukturierte Tabelle als Ausgabe erscheint.</p>
<div><pre><code><span>></span> <span>ls</span>
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span>#  â”‚         name          â”‚ type â”‚   size    â”‚  modified   â”‚</span>
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <span>0</span> â”‚ <span>404</span>.html              â”‚ <span>file</span> â”‚     <span>429</span> B â”‚ <span>3</span> days ago  â”‚
â”‚  <span>1</span> â”‚ CONTRIBUTING.md       â”‚ <span>file</span> â”‚     <span>955</span> B â”‚ <span>8</span> mins ago  â”‚
â”‚  <span>2</span> â”‚ Gemfile               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>3</span> â”‚ Gemfile.lock          â”‚ <span>file</span> â”‚   <span>6.9</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>4</span> â”‚ LICENSE               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>5</span> â”‚ README.md             â”‚ <span>file</span> â”‚     <span>213</span> B â”‚ <span>3</span> days ago  â”‚
<span>..</span>.
</code></pre></div><p>Diese Tabelle ist mehr als nur eine andere Darstellungsform. Wie Tabellen in Spreadsheets erlaubt es diese Tabelle mit den Daten interaktiver zu arbeiten.</p>
<p>Um das zu demonstrieren, wird der Inhalt der Tabelle zunÃ¤chst nach der GrÃ¶ÃŸe sortiert. Um das zu realisieren, wird die Ausgabe von <code>ls</code> genommen und in ein Befehl gegeben, der Tabellen auf Basis von Daten in einer Spalte neu anordnen kann.</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> reverse
â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span>#  â”‚         name          â”‚ type â”‚   size    â”‚  modified   â”‚</span>
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <span>0</span> â”‚ Gemfile.lock          â”‚ <span>file</span> â”‚   <span>6.9</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>1</span> â”‚ SUMMARY.md            â”‚ <span>file</span> â”‚   <span>3.7</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>2</span> â”‚ Gemfile               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>3</span> â”‚ LICENSE               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚
â”‚  <span>4</span> â”‚ CONTRIBUTING.md       â”‚ <span>file</span> â”‚     <span>955</span> B â”‚ <span>9</span> mins ago  â”‚
â”‚  <span>5</span> â”‚ books.md              â”‚ <span>file</span> â”‚     <span>687</span> B â”‚ <span>3</span> days ago  â”‚
<span>..</span>.
</code></pre></div><p>Um das Ganze zu realisieren, mussten hierzu nicht Argumente an <code>ls</code> Ã¼bergeben werden. Stattdessen wird der <code>sort-by</code> Befehl verwendet, den Nu bereitstellt, um Daten zu sortieren. Damit die grÃ¶ÃŸten Dateien oben erscheinen wurde zusÃ¤tzlich die Option <code>reverse</code> angegeben.</p>
<p>Nu stellt sehr viele Befehle bereit, die mit Tabellen arbeiten kÃ¶nnen. Beispielsweise kann die Ausgabe von <code>ls</code> auch derart gefiltert werden, dass nur Datei mit einer GrÃ¶ÃŸe von mehr als einem Kilobyte angezeigt werden:</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 1kb
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span># â”‚       name        â”‚ type â”‚  size   â”‚  modified  â”‚</span>
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ <span>0</span> â”‚ Gemfile           â”‚ <span>file</span> â”‚ <span>1.1</span> KiB â”‚ <span>3</span> days ago â”‚
â”‚ <span>1</span> â”‚ Gemfile.lock      â”‚ <span>file</span> â”‚ <span>6.9</span> KiB â”‚ <span>3</span> days ago â”‚
â”‚ <span>2</span> â”‚ LICENSE           â”‚ <span>file</span> â”‚ <span>1.1</span> KiB â”‚ <span>3</span> days ago â”‚
â”‚ <span>3</span> â”‚ SUMMARY.md        â”‚ <span>file</span> â”‚ <span>3.7</span> KiB â”‚ <span>3</span> days ago â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</code></pre></div><p>Wie in der Unix-Philosophie, erlauben Befehle, die untereinander Daten austauschen kÃ¶nnen, viele verschiedene Kombinationen um Aufgaben zu lÃ¶sen. Wie in folgendem Beispiel:</p>
<div><pre><code><span>></span> <span>ps</span>
â•­â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚  <span>#  â”‚ pid  â”‚         name         â”‚ status  â”‚  cpu  â”‚    mem    â”‚ virtual  â”‚</span>
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   <span>0</span> â”‚ <span>7570</span> â”‚ nu                   â”‚ Running â”‚  <span>1.96</span> â”‚  <span>23.2</span> MiB â”‚ <span>32.8</span> GiB â”‚
â”‚   <span>1</span> â”‚ <span>3533</span> â”‚ remindd              â”‚ Sleep   â”‚  <span>0.00</span> â”‚ <span>103.6</span> MiB â”‚ <span>32.3</span> GiB â”‚
â”‚   <span>2</span> â”‚ <span>3495</span> â”‚ TVCacheExtension     â”‚ Sleep   â”‚  <span>0.00</span> â”‚  <span>11.9</span> MiB â”‚ <span>32.2</span> GiB â”‚
â”‚   <span>3</span> â”‚ <span>3490</span> â”‚ MusicCacheExtension  â”‚ Sleep   â”‚  <span>0.00</span> â”‚  <span>12.9</span> MiB â”‚ <span>32.2</span> GiB â”‚
<span>..</span>.
</code></pre></div><p>Der <code>ps</code> Befehl erlaubt es auf Linux-Systemen alle laufenden Prozesse, deren Status und Name abzufragen. Des Weiteren gibt er Informationen zu CPU-Last der einzelnen Prozesse an.</p>
<p>Was macht man, wenn man nur Prozesse sehen mÃ¶chte, die aktuelle aktiv die CPU nutzen? Wie zuvor beim <code>ls</code> Befehl, kann mit der durch <code>ps</code> zurÃ¼ckgegebenen Tabelle gearbeitet werden:</p>
<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>5</span>
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span># â”‚ pid  â”‚      name      â”‚ status  â”‚  cpu   â”‚    mem    â”‚ virtual  â”‚</span>
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ <span>0</span> â”‚ <span>1583</span> â”‚ Terminal       â”‚ Running â”‚  <span>20.69</span> â”‚ <span>127.8</span> MiB â”‚ <span>33.0</span> GiB â”‚
â”‚ <span>1</span> â”‚  <span>579</span> â”‚ photoanalysisd â”‚ Running â”‚ <span>139.50</span> â”‚  <span>99.9</span> MiB â”‚ <span>32.3</span> GiB â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</code></pre></div><p>Bis jetzt wurden <code>ls</code> und <code>ps</code> genutzt, um Dateien und Prozesse aufzulisten. Nu besitzt aber noch viele weitere Befehle die nÃ¼tzliche Informationen in Tabellenform ausgeben. Dazu wird nun ein Block auf die Befehle <code>date</code> und <code>sys</code> geworfen.</p>
<p>Wenn <code>date now</code> aufgerufen wird, werden Informationen zum aktuellen Datum und der aktuellen Uhrzeit ausgegeben.</p>
<div><pre><code><span>></span> <span>date</span> now
<span>2022</span>-03-07 <span>14</span>:14:51.684619600 -08:00
</code></pre></div><p>Um das Datum in Tabellenform zu bekommen, kann es zusÃ¤tzlich in <code>date to-table</code> gegeben werden:</p>
<div><pre><code><span>></span> <span>date</span> now <span>|</span> <span>date</span> to-table
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span># â”‚ year â”‚ month â”‚ day â”‚ hour â”‚ minute â”‚ second â”‚ timezone â”‚</span>
â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ <span>0</span> â”‚ <span>2022</span> â”‚     <span>3</span> â”‚   <span>7</span> â”‚   <span>14</span> â”‚     <span>45</span> â”‚      <span>3</span> â”‚ -08:00   â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</code></pre></div><p>Der Aufruf von <code>sys</code> gibt Informationen zum System aus, auf dem Nu lÃ¤uft:</p>
<div><pre><code><span>></span> sys
â•­â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ <span>host</span>  â”‚ <span>{</span>record <span>6</span> fields<span>}</span> â”‚
â”‚ cpu   â”‚ <span>[</span>table <span>4</span> rows<span>]</span>    â”‚
â”‚ disks â”‚ <span>[</span>table <span>3</span> rows<span>]</span>    â”‚
â”‚ mem   â”‚ <span>{</span>record <span>4</span> fields<span>}</span> â”‚
â”‚ temp  â”‚ <span>[</span>table <span>1</span> row<span>]</span>     â”‚
â”‚ net   â”‚ <span>[</span>table <span>4</span> rows<span>]</span>    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</code></pre></div><p>Diese Ausgabe unterscheidet sich nun von den vorherigen. Der <code>sys</code> Befehl gibt eine Tabelle zurÃ¼ck, die selbst strukturierte Tabellen in den Zellen enthÃ¤lt anstatt nur einfache Werte. Um auf die Daten zuzugreifen, wird der <em>get</em> Befehl verwendet:</p>
<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ name           â”‚ Debian GNU/Linux       â”‚
â”‚ os version     â”‚ <span>11</span>                     â”‚
â”‚ kernel version â”‚ <span>5.10</span>.92-v8+            â”‚
â”‚ <span>hostname</span>       â”‚ lifeless               â”‚
â”‚ <span>uptime</span>         â”‚ 19day 21hr 34min 45sec â”‚
â”‚ sessions       â”‚ <span>[</span>table <span>1</span> row<span>]</span>          â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
</code></pre></div><p>Der <code>get</code> Befehl erlaubt es, in die Inhalte einer Tabellenzelle einzutauchen. Hier wird beispielsweise die Spalte &quot;host&quot; nÃ¤her betrachtet, die Informationen Ã¼ber den Host, auf dem Nu lÃ¤uft, enthÃ¤lt. Der Name des Betriebssystem (OS), die CPU und mehr. Nun sollen die Namen der Nutzer auf dem System ausgegeben werden:</p>
<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name
â•­â”€â”€â”€â”¬â”€â”€â”€â”€â•®
â”‚ <span>0</span> â”‚ jt â”‚
â•°â”€â”€â”€â”´â”€â”€â”€â”€â•¯
</code></pre></div><p>Aktuelle existiert nur ein Nutzer namens &quot;jt&quot;. Wie zu sehen ist, kann ein ganzer Pfad fÃ¼r Spalten angegeben werden - nicht nur der Name der Spalte. Nu wird den Pfad nehmen und durch die entsprechenden Daten in der Tabelle gehen.</p>
<p>Und noch etwas anderes ist anders. Anstatt einer Tabelle mit Daten wurde nur ein einzelnes Element ausgegeben: der String &quot;jt&quot;. Nu arbeitet sowohl mit Tabellen voller Daten als auch mit Strings. Strings sind ein wichtiger Bestandteil, um mit Befehlen auÃŸerhalb von Nu zu arbeiten.</p>
<p>Nun soll aufgezeigt werden, wie mit Strings auÃŸerhalb von Nu gearbeitet wird. Dazu wird das vorige Beispiel erweitert. Die Daten werden an den externen <code>echo</code> Befehl weitergegeben (das <code>^</code> teilt Nu mit, dass nicht der eingebaute <code>echo</code> Befehl verwendet werden soll):</p>
<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> ^echo <span>$it</span> <span>}</span>
jt
</code></pre></div><p>Das sieht jetzt genau gleich aus wie die Ausgabe zuvor. Was soll das? Es ist Ã¤hnlich aber mit einem entscheidenden Unterschied: <code>^echo</code> wurde aufgerufen. Das erlaubt es uns Daten aus Nu heraus an beliebige Befehle auÃŸerhalb von Nu zu geben wie <code>echo</code> oder <code>git</code>.</p>
<p><em>Hinweis: Hilfe zu allen in Nu eingebauten Befehlen kann mit dem Befehl <code>help</code> angezeigt werden</em>:</p>
<div><pre><code><span>></span> <span>help</span> path
Explore and manipulate paths.

There are three ways to represent a path:

* As a path literal, e.g., <span>'/home/viking/spam.txt'</span>
* As a structured path: a table with <span>'parent'</span>, <span>'stem'</span>, and <span>'extension'</span> <span>(</span>and
* <span>'prefix'</span> on Windows<span>)</span> columns. This <span>format</span> is produced by the <span>'path parse'</span>
  subcommand.
* As an inner list of path parts, e.g., <span>'[[ / home viking spam.txt ]]'</span><span>.</span>
  Splitting into parts is <span>done</span> by the <span><span>`</span>path <span>split</span><span>`</span></span> command.

All subcommands accept all three variants as an input. Furthermore, the <span>'path
join'</span> subcommand can be used to <span>join</span> the structured path or path parts back into
the path literal.

Usage:
  <span>></span> path

Subcommands:
  path <span>basename</span> - Get the final component of a path
  path <span>dirname</span> - Get the parent directory of a path
  path exists - Check whether a path exists
  path <span>expand</span> - Try to <span>expand</span> a path to its absolute form
  path <span>join</span> - Join a structured path or a list of path parts.
  path parse - Convert a path into structured data.
  path relative-to - Get a path as relative to another path.
  path <span>split</span> - Split a path into parts by a separator.
  path <span>type</span> - Get the <span>type</span> of the object a path refers to <span>(</span>e.g., file, dir, symlink<span>)</span>

Flags:
  -h, --help
      Display this <span>help</span> message
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Aliase</title>
    <id>www.nushell.sh/de/book/aliase.html</id>
    <link href="www.nushell.sh/de/book/aliase.html"/>
    <updated>2022-06-03T13:51:58.407Z</updated>
    <content type="html"><![CDATA[<h1 id="aliase" tabindex="-1"> Aliase</h1>
<p>Aliase in Nushell bieten eine einfache MÃ¶glichkeit, um Texte zur ersetzen. Damit ist es mÃ¶glich, einen Kurznamen fÃ¼r lÃ¤ngere Befehle zu definieren - inklusive der Argumente.</p>
<p>Beispielsweise kann ein Alias namens <code>ll</code> definiert werden, der den lÃ¤ngeren Befehl <code>ls -l</code> ersetzt:</p>
<div><pre><code>> alias ll = ls -l
</code></pre></div><p>Nun kann der Alias aufgerufen werden:</p>
<div><pre><code>> ll
</code></pre></div><p>Wenn das getan wird, wirkt es, als sei <code>ls -l</code> aufgerufen worden. Das bietet auch die MÃ¶glichkeit weitere Parameter anzugeben. So kann auch geschrieben werden:</p>
<div><pre><code>> ll -a
</code></pre></div><p>Das ist Ã¤quivalent zu <code>ls -l -a</code>. Deutlich kÃ¼rzer.</p>
<h2 id="persistenz" tabindex="-1"> Persistenz</h2>
<p>FÃ¼r Informationen, um Aliase dauerhaft zu speichern, damit diese immer in Nushell nutzbar sind, kann ein Blick auf das <a href="/de/book/konfiguration.html">Konfigurationskapitel</a> geworfen werden.</p>
]]></content>
  </entry>
  <entry>
    <title type="html">Command Reference</title>
    <id>www.nushell.sh/de/book/command_reference.html</id>
    <link href="www.nushell.sh/de/book/command_reference.html"/>
    <updated>2022-06-03T13:51:58.407Z</updated>
    <content type="html"><![CDATA[<h1 id="command-reference" tabindex="-1"> Command Reference</h1>
<table>
  <tr>
    <th>Command</th>
    <th>Beschreibung</th>
  </tr>
  <tr v-for="command in commands">
   <td><a :href="command.path"><code>{{ command.title }}</code></a></td>
   <td style="white-space: pre-wrap;">{{ command.frontmatter.usage }}</td>
  </tr>
</table>
]]></content>
  </entry>
  <entry>
    <title type="html">Eigene Befehle</title>
    <id>www.nushell.sh/de/book/eigene_befehle.html</id>
    <link href="www.nushell.sh/de/book/eigene_befehle.html"/>
    <updated>2022-06-03T13:51:58.407Z</updated>
    <content type="html"><![CDATA[<h1 id="eigene-befehle" tabindex="-1"> Eigene Befehle</h1>
<p>Die FÃ¤higkeit von Nu, lange Pipelines zu verarbeiten, erlauben es groÃŸe Kontrolle Ã¼ber Daten und das System zu haben. Das Ganze kommt allerdings zum Preis von viel Tipparbeit. Idealerweise sollte es eine MÃ¶glichkeit geben, mÃ¼hsam gebaute Pipelines zu speichern und wieder und wieder auszufÃ¼hren.</p>
<p>Hier kommen eigene Befehle ins Spiel.</p>
<p>Eine beispielhafte Definition eines eigenen Befehls sieht wie folgt aus:</p>
<div><pre><code>def greet [name] {
  echo &quot;hello&quot; $name
}
</code></pre></div><p>In dieser Definition, wird ein Befehl <code>greet</code> beschrieben, der einen Parameter <code>name</code> konsumiert. Nach diesem Parameter erfolgt die Beschreibung was passiert, wenn der Befehl ausgefÃ¼hrt wird. Wenn der Befehl aufgerufen wird, wird der Wert, der als Parameter <code>name</code> Ã¼bergeben wurde, in die Variable <code>$name</code> geschrieben, die im Codeblock verfÃ¼gbar ist.</p>
<p>Um den obigen Befehl auszufÃ¼hren wird er wie ein eingebauter Befehl aufgerufen:</p>
<div><pre><code>> greet "world"
</code></pre></div><p>Wenn das getan wird, wird eine Ausgabe erzeugt, die wie die der eingebauten Befehle aussieht:</p>
<div><pre><code>â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€
 0 â”‚ hello
 1 â”‚ world
â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€
</code></pre></div><h2 id="namen-von-befehlen" tabindex="-1"> Namen von Befehlen</h2>
<p>In Nushell ist ein valider Name eines Befehls ein String aus Zeichen oder ein String in AnfÃ¼hrungszeichen. Beispiele hierfÃ¼r sind: <code>greet</code>, <code>get-size</code>, <code>mycommand123</code>, <code>&quot;mycommand&quot;</code>, <code>ðŸ˜Š</code> und <code>123</code>.</p>
<p><em>Hinweis: Es wird empfohlen Worte in Befehlen mit <code>-</code> zur besseren Lesbarkeit zu trennen.</em> Beispiele: <code>get-size</code> anstatt <code>getsize</code> oder <code>get_size</code>.</p>
<h2 id="unterbefehle" tabindex="-1"> Unterbefehle</h2>
<p>Es ist auch mÃ¶glich Unterbefehle zu definieren. Dazu wird der Unterbefehl vom Superbefehl durch ein Leerzeichen getrennt. Wenn beispielsweise der Befehl <code>str</code> durch einen Unterbefehl <code>mycommand</code> erweitert werden soll, funktioniert das wie folgt:</p>
<div><pre><code>def &quot;str mycommand&quot; [] {
  echo hello
}
</code></pre></div><p>Jetzt kann der eigene Unterbefehl aufgerufen werden, als ob er ein eingebauter Befehl von <code>str</code> wÃ¤re:</p>
<div><pre><code>> str mycommand
</code></pre></div><h2 id="typen-von-parametern" tabindex="-1"> Typen von Parametern</h2>
<p>Wenn eigene Befehle definiert werden, kann optional auch der Typ jedes Parameters angegeben werden. Das obige Beispiel kann beispielsweise wie folgt abgeÃ¤ndert werden:</p>
<div><pre><code>def greet [name: string] {
  echo &quot;hello&quot; $name
}
</code></pre></div><p>Die Typen der Parameter anzugeben ist optional. Nushell erlaubt es diese wegzulassen und behandelt diese dann als Typ <code>any</code>. Es kann also jede Art von Typ verarbeitet werden. Wenn ein Typ angegeben wurde, Ã¼berprÃ¼ft Nushell den Typ, wenn die Funktion aufgerufen wird.</p>
<p>Beispielhaft soll nur noch ein <code>int</code> als Typ erlaubt sein:</p>
<div><pre><code>def greet [name: int] {
  echo &quot;hello&quot; $name
}

greet world
</code></pre></div><p>Wenn versucht wird, den oberen Code auszufÃ¼hren, wird Nu darauf aufmerksam machen, dass die Typen nicht passen und die AusfÃ¼hrung stoppen:</p>
<div><pre><code>error: Type Error
  â”Œâ”€ shell:6:7
  â”‚
5 â”‚ greet world
  â”‚       ^^^^^ Expected int, found world
</code></pre></div><p>Dies kann dabei helfen Nutzer darauf aufmerksam zu machen, welche Art von Typ erlaubt ist.</p>
<p>Die aktuell erlaubten Typen sind (mit Version 0.59.0 und neuer):</p>
<ul>
<li><code>any</code></li>
<li><code>block</code></li>
<li><code>cell-path</code></li>
<li><code>duration</code></li>
<li><code>path</code></li>
<li><code>expr</code></li>
<li><code>filesize</code></li>
<li><code>glob</code></li>
<li><code>int</code></li>
<li><code>math</code></li>
<li><code>number</code></li>
<li><code>operator</code></li>
<li><code>range</code></li>
<li><code>cond</code></li>
<li><code>bool</code></li>
<li><code>signature</code></li>
<li><code>string</code></li>
<li><code>variable</code></li>
</ul>
<h2 id="flags" tabindex="-1"> Flags</h2>
<p>ZusÃ¤tzlich zu den obigen Parametern, kÃ¶nnen auch namenabhÃ¤ngige Parameter verwendet werden, indem Flags fÃ¼r eigene Befehle definiert werden.</p>
<p>Zum Beispiel:</p>
<div><pre><code>def greet [
  name: string
  --age: int
] {
  echo $name $age
}
</code></pre></div><p>In der obigen Definition von <code>greet</code>, werden ein fester Parameter <code>name</code> und eine Flag <code>age</code> definiert. Damit ist es mÃ¶glich, dem Befehl <code>greet</code> optional den Parameter <code>age</code> zu Ã¼bergeben.</p>
<p>Das obige Beispiel kann wie folgt aufgerufen werden:</p>
<div><pre><code>> greet world --age 10
</code></pre></div><p>Oder:</p>
<div><pre><code>> greet --age 10 world
</code></pre></div><p>Oder gleich ganz ohne Flag:</p>
<div><pre><code>> greet world
</code></pre></div><p>Flags kÃ¶nnen auch so definiert werden, dass es eine Kurzform gibt. Das erlaubt es sowohl eine kurze als auch eine einfach lesbare lange Flag fÃ¼r die selbe Aufgabe zu haben.</p>
<p>Das Beispiel wird hier, um eine Kurzform fÃ¼r die Flag <code>age</code> erweitert:</p>
<div><pre><code>def greet [
  name: string
  --age (-a): int
] {
  echo $name $age
}
</code></pre></div><p><em>Hinweis:</em> Flags sind benannt nach der langen Form des Namens. Im obigen Beispiel erfolgt der Zugriff immer Ã¼ber <code>$age</code> und nicht Ã¼ber <code>$a</code>.</p>
<p>Nun kann diese neue Version von <code>greet</code> wie folgt aufgerufen werden:</p>
<div><pre><code>> greet -a 10 hello
</code></pre></div><h2 id="dokumentation-fur-den-eigenen-befehl" tabindex="-1"> Dokumentation fÃ¼r den eigenen Befehl</h2>
<p>Um Nutzern eines eigenen Befehls zu helfen, kÃ¶nnen diese und ihre Parameter mit zusÃ¤tzlichen Beschreibungen versehen werden.</p>
<p>Es wird weiterhin das obige Beispiel verwendet:</p>
<div><pre><code>def greet [
  name: string
  --age (-a): int
] {
  echo $name $age
}
</code></pre></div><p>Wenn der Befehl definiert ist kann <code>help greet</code> aufgerufen werden, um Informationen zum Befehl zu erhalten:</p>
<div><pre><code>Usage:
  > greet &lt;name> {flags}

Parameters:
  &lt;name>

Flags:
  -h, --help: Display this help message
  -a, --age &lt;integer>
</code></pre></div><p>Wie zu sehen ist, werden der Parameter und die Flag, die definiert wurden, aufgelistet. ZusÃ¤tzlich gibt es noch die Flag <code>-h</code>, die jeder Befehl hat.</p>
<p>Um diese Hilfe zu verbessern, kÃ¶nnen Beschreibungen zur Definition hinzugefÃ¼gt werden:</p>
<div><pre><code># A greeting command that can greet the caller
def greet [
  name: string      # The name of the person to greet
  --age (-a): int   # The age of the person
] {
  echo $name $age
}
</code></pre></div><p>Diese Kommentare, die zur Definition und den Parametern hinzugefÃ¼gt wurden, werden sichtbar, wenn die Hilfe zum Befehl aufgerufen wird.</p>
<p>Wenn jetzt <code>help greet</code> ausgefÃ¼hrt wird, wird ein hilfreicherer Text angezeigt:</p>
<div><pre><code>A greeting command that can greet the caller

Usage:
  > greet &lt;name> {flags}

Parameters:
  &lt;name> The name of the person to greet

Flags:
  -h, --help: Display this help message
  -a, --age &lt;integer>: The age of the person
</code></pre></div><h2 id="ausgabe" tabindex="-1"> Ausgabe</h2>
<p>Eigene Befehle streamen ihre Ausgabe gleich wie eingebaute Befehle. Beispielsweise soll die folgende Pipeline umgebaut werden:</p>
<div><pre><code>&gt; ls | get name
</code></pre></div><p><code>ls</code> soll jetzt in einen neuen, eigenen Befehl verschoben werden:</p>
<div><pre><code>def my-ls [] { ls }
</code></pre></div><p>Die Ausgabe dieses Befehls, kann identisch zur Ausgabe von <code>ls</code> verwendet werden.</p>
<div><pre><code>> my-ls | get name
â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 0 â”‚ myscript.nu
 1 â”‚ myscript2.nu
 2 â”‚ welcome_to_nushell.md
â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
</code></pre></div><p>Das erlaubt es sehr einfach eigene Befehle zu definieren und deren Ausgabe zu verwenden. Ein Hinweis: Es werden keine return Statements wie in anderen Sprachen verwendet. Stattdessen werden in Nushell Pipelines gebaut, die ihre Ausgabe zur verbundenen Pipeline streamen.</p>
<h2 id="eingabe" tabindex="-1"> Eingabe</h2>
<p>Eigene Befehle kÃ¶nnen, wie andere Befehle, auch Eingaben verarbeiten. Diese Eingabe wird durch die Pipeline an den Codeblock des eigenen Befehls Ã¼bergeben.</p>
<p>Hier soll nun beispielhaft ein eigener echo-Befehl definiert werden, der eine weitere Zeile nach jeder Zeile der Eingabe ausgibt:</p>
<div><pre><code>def my-echo [] {
  each {
    echo $it &quot;--&quot;
  }
}
</code></pre></div><p>Wenn dieser neue Befehl nun in einer Pipeline aufgerufen wird, sieht die Ausgabe wie folgt aus:</p>
<div><pre><code>> echo foo bar | my-echo
â”€â”€â”€â”¬â”€â”€â”€â”€â”€
 0 â”‚ foo
 1 â”‚ --
 2 â”‚ bar
 3 â”‚ --
â”€â”€â”€â”´â”€â”€â”€â”€â”€
</code></pre></div><h2 id="persistenz" tabindex="-1"> Persistenz</h2>
<p>Um Informationen darÃ¼ber zu erhalten, wie eigene Befehle bei jedem Start von Nushell verfÃ¼gbar bleiben, sei auf das <a href="/de/book/konfiguration.html">Konfigurationskapitel</a> verwiesen.</p>
]]></content>
  </entry>
  <entry>
    <title type="html">Aufruf von Systembefehlen</title>
    <id>www.nushell.sh/de/book/escaping.html</id>
    <link href="www.nushell.sh/de/book/escaping.html"/>
    <updated>2022-06-03T13:51:58.408Z</updated>
    <content type="html"><![CDATA[<h1 id="aufruf-von-systembefehlen" tabindex="-1"> Aufruf von Systembefehlen</h1>
<p>Nushell stellt einen identischen Satz an Befehlen fÃ¼r verschiedene Systeme zur VerfÃ¼gung, die Ã¼berall dieselbe Syntax und FunktionalitÃ¤t haben. Manchmal ist es jedoch nÃ¶tig, den gleichnamigen, vom System selbst bereitgestellten, Befehl aufzurufen. Um beispielsweise den <code>ls</code> oder <code>date</code> Befehl des Systems auszufÃ¼hren, wird das Zirkumflex (<code>^</code>) dem Befehl vorangestellt:</p>
<p>Nushell Befehl:</p>
<div><pre><code>> ls
</code></pre></div><p>Aufruf des Systembefehls:</p>
<div><pre><code>> ^ls
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Nu installieren</title>
    <id>www.nushell.sh/de/book/installation.html</id>
    <link href="www.nushell.sh/de/book/installation.html"/>
    <updated>2022-06-03T13:51:58.408Z</updated>
    <content type="html"><![CDATA[<h1 id="nu-installieren" tabindex="-1"> Nu installieren</h1>
<p>Der aktuell beste Weg Nu zu bekommen ist, es von <a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a> zu installieren, BinÃ¤rdateien von unserer <a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">Release-Seite</a> herunterzuladen oder es selbst zu kompilieren.</p>
<h2 id="binardatei" tabindex="-1"> BinÃ¤rdatei</h2>
<p>Von der <a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">Release-Seite</a> kann Nushell bereits kompiliert heruntergeladen werden. Alternativ kann Nushell, wenn <a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a> verwendet wird, mit dem Befehl <code>brew install nushell</code> installiert werden. Unter Windows kÃ¶nnen <a href="https://docs.microsoft.com/en-us/windows/package-manager/winget/" target="_blank" rel="noopener noreferrer">Winget</a> oder <a href="https://chocolatey.org/" target="_blank" rel="noopener noreferrer">Chocolatey</a> zur Installation verwendet werden: <code>winget install nushell</code> beziehungsweise <code>choco install nushell</code>.</p>
<h3 id="windows" tabindex="-1"> Windows</h3>
<p><strong>Achtung:</strong> Nu funtioniert aktuell auf Windows 10 und hat keine UnterstÃ¼tzung fÃ¼r Windows 7/8.1.</p>
<p>Die aktuelle, verÃ¶ffentlichte <code>.zip</code>-Datei von der <a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">Release-Seite</a> herunterladen und den Inhalt extrahieren nach:</p>
<div><pre><code>C:<span>\</span>Program Files
</code></pre></div><p>Danach den <code>nu</code> beinhaltenden Ordner der Umgebungsvariable PATH hinzufÃ¼gen. Wenn das passiert ist, kann <code>nu</code> wie folgt gestartet werden:</p>
<div><pre><code><span>></span> nu
C:<span>\</span>Users<span>\</span>user<span>></span>
</code></pre></div><p>FÃ¼r Nutzer des <a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener noreferrer">Windows Terminal</a> kann <code>nu</code> als Standard-Shell gesetzt werden, indem:</p>
<div><pre><code><span>{</span>
  <span>"guid"</span><span>:</span> <span>"{2b372ca1-1ee2-403d-a839-6d63077ad871}"</span>,
  <span>"hidden"</span><span>:</span> false,
  <span>"icon"</span><span>:</span> <span>"https://www.nushell.sh/icon.png"</span>,
  <span>"name"</span><span>:</span> <span>"Nu Shell"</span>,
  <span>"commandline"</span><span>:</span> <span>"nu.exe"</span>
<span>}</span>
</code></pre></div><p>zu <code>&quot;profiles&quot;</code> in den Terminal Einstellungen (JSON-Datei) hinzufÃ¼gt wird. Zu guter Letzt, muss nur noch <code>&quot;defaultProfile&quot;</code> angepasst werden:</p>
<div><pre><code><span>"defaultProfile"</span><span>:</span> <span>"{2b372ca1-1ee2-403d-a839-6d63077ad871}"</span>,
</code></pre></div><p>Jetzt sollte sich <code>nu</code> beim Start von Windows Terminal Ã¶ffnen.</p>
<h2 id="vorbereitungen" tabindex="-1"> Vorbereitungen</h2>
<p>Bevor Nu installiert werden kann, muss sichergestellt werden, dass das System die nÃ¶tigen Anforderungen erfÃ¼llt. Aktuell bedeutet das sicherzustellen, dass die Rust-Toolchain und lokale AbhÃ¤ngigkeiten installiert sind.</p>
<h3 id="installieren-einer-compiler-suite" tabindex="-1"> Installieren einer Compiler-Suite</h3>
<p>Damit Rust richtig funktioniert, muss eine kompatible Compiler-Suite auf dem System installiert sein. Die empfohlenen Compiler-Suites sind:</p>
<ul>
<li>Linux: GCC oder Clang</li>
<li>macOS: Clang (Xcode installieren)</li>
<li>Windows: MSVC (installieren von <a href="https://visualstudio.microsoft.com/vs/community/" target="_blank" rel="noopener noreferrer">Visual Studio Community Edition</a> oder der <a href="https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022" target="_blank" rel="noopener noreferrer">Visual Studio Build Tools</a>)
<ul>
<li>Sicherstellen, dass &quot;Desktop development with C++&quot; installiert wird</li>
<li>Jede Visual Studio Edition sollte funktionieren (Community ist gratis)</li>
</ul>
</li>
</ul>
<h3 id="rust-installieren" tabindex="-1"> Rust installieren</h3>
<p>Wenn Rust noch nicht auf dem System installiert ist, ist <a href="https://rustup.rs/" target="_blank" rel="noopener noreferrer">rustup</a> der beste Weg es zu bekommen. Rustup ist ein Programm um Rust-Installationen zu managen wie beispielsweise verschiedene Rust-Versionen.</p>
<p>Nu benÃ¶tigt aktuell die <strong>latest stable (1.55 oder neuer)</strong> Version von Rust. Der einfachste Weg ist es, <code>rustup</code> die korrekte Version fÃ¼r finden zu lassen. Wenn <code>rustup</code> zum ersten Mal gestartet wird, wird nachgefragt, welche Version installiert werden soll:</p>
<div><pre><code>Current installation options:

default <span>host</span> triple: x86_64-unknown-linux-gnu
default toolchain: stable
profile: default
modify <span>PATH</span> variable: <span>yes</span>

<span>1</span><span>)</span> Proceed with installation <span>(</span>default<span>)</span>
<span>2</span><span>)</span> Customize installation
<span>3</span><span>)</span> Cancel installation
</code></pre></div><p>Wenn Sie bereit sind, drÃ¼cken Sie <code>1</code> und dann <code>Enter</code>.</p>
<p>Wenn Rust nicht via <code>rustup</code> installiert werden soll, kÃ¶nnen auch andere Methoden verwendet werden um es zu installieren (z.B. vom Paketmanager der Linux-Distro). Dabei muss sichergestellt werden, dass es sich um Rust-Version 1.55 oder neuer handelt.</p>
<h2 id="abhangigkeiten" tabindex="-1"> AbhÃ¤ngigkeiten</h2>
<h3 id="debian-ubuntu" tabindex="-1"> Debian/Ubuntu</h3>
<p>Es mÃ¼ssen die Pakete <code>pkg-config</code> und <code>libssl-dev</code> installiert werden:</p>
<div><pre><code><span>apt</span> <span>install</span> pkg-config libssl-dev
</code></pre></div><p>Linux-Nutzer die die optionalen Funktionen <code>rawkey</code> und <code>clipboard</code> verwenden mÃ¶chten, mÃ¼ssen auÃŸerdem die Pakete <code>libx11-dev</code> und <code>libxcb-composite0-dev</code> installieren:</p>
<div><pre><code><span>apt</span> <span>install</span> libxcb-composite0-dev libx11-dev
</code></pre></div><h3 id="rhel-basierte-distributionen" tabindex="-1"> RHEL basierte Distributionen</h3>
<p>FÃ¼r RHEL basierte Distributionen mÃ¼ssen die Pakete <code>libxcb</code>, <code>openssl-devel</code> und <code>libX11-devel</code> installiert werden:</p>
<div><pre><code>yum <span>install</span> libxcb openssl-devel libX11-devel
</code></pre></div><h3 id="macos" tabindex="-1"> macOS</h3>
<p>Mittels <a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a>, mÃ¼ssen die Pakete <code>openssl</code> und <code>cmake</code> Ã¼ber folgenden Befehl installiert werden:</p>
<div><pre><code>brew <span>install</span> openssl cmake
</code></pre></div><h2 id="installieren-von-crates-io" tabindex="-1"> Installieren von <a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a></h2>
<p>Wenn alle die AbhÃ¤ngigkeitenn, die fÃ¼r Nu benÃ¶tigt werden, installiert sind, kann <code>cargo</code> verwendet werden um Nu zu installieren.</p>
<div><pre><code><span>></span> cargo <span>install</span> nu
</code></pre></div><p>Das war's! Cargo wird Nu und seine anderen AbhÃ¤ngigkeiten herunterladen, kompilieren und schlieÃŸlich im cargo <code>bin</code> Pfad installieren, damit es benutzt werden kann.</p>
<p>Wenn mehr FunktionalitÃ¤ten installiert werden sollen, kann der folgende Befehl verwendet werden:</p>
<div><pre><code><span>></span> cargo <span>install</span> nu --features<span>=</span>extra
</code></pre></div><p>Um alle verfÃ¼gbaren FunktionalitÃ¤ten zu bekommen, ist es am einfachsten einen Checkout durchzufÃ¼hren und es selbst mit Hilfe der Rust-Tools zu kompilieren:</p>
<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git
<span>></span> <span>cd</span> nushell
nushell<span>></span> cargo <span>install</span> --path <span>.</span> --features<span>=</span>extra
</code></pre></div><p>Damit das funktioniert, sollte sichergestellt werden, dass alle oben genannten AbhÃ¤ngigkeiten auf dem System installiert sind.</p>
<p>Wenn Nu schlieÃŸlich installiert ist, kann die Shell mit dem <code>nu</code>-Befehl gestartet werden:</p>
<div><pre><code>$ nu
/home/jt/Source<span>></span>
</code></pre></div><h2 id="kompilieren-von-quelldateien" tabindex="-1"> Kompilieren von Quelldateien</h2>
<p>Nu kann auch direkt aus den Quelldateien, die auf GitHub verfÃ¼gbar sind, kompiliert werden. Das stellt unmittelbar die neuesten Funktionen und Fehlerbehebungen von Nu zur VerfÃ¼gung.</p>
<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git
</code></pre></div><p>Git clont das main nushell Repo. Von da aus, kann Nu, wenn <code>rustup</code> verwendet wird, wie folgt kompiliert und gestartet werden:</p>
<div><pre><code><span>></span> <span>cd</span> nushell
nushell<span>></span> cargo build --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --features<span>=</span>extra
</code></pre></div><p>Nu kann auch in &quot;release&quot; Modus kompiliert und gestartet werden:</p>
<div><pre><code>nushell<span>></span> cargo build --release --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --release --features<span>=</span>extra
</code></pre></div><p>Leute, die sich mit Rust auskennen, wundern sich womÃ¶glich, warum hier sowohl ein <code>build</code> als auch ein <code>run</code> durchgefÃ¼hrt wird, obwohl <code>run</code> standardmÃ¤ÃŸig auch einen Build durchfÃ¼hrt. Das ist nÃ¶tig, um ein Problem mit der neuen <code>default-run</code>-Option von Cargo zu umgehen, damit alle Plugins kompiliert werden. Dies wird unter UmstÃ¤nden in Zukunft nicht mehr nÃ¶tig sein.</p>
<h2 id="als-login-shell-verwenden" tabindex="-1"> Als Login-Shell verwenden</h2>
<p><strong>!!! Nu befindet sich noch in der Entwicklung und ist unter UmstÃ¤nden nicht stabil genug fÃ¼r die tÃ¤gliche Nutzung. !!!</strong></p>
<p>Um die Login-Shell festzulegen, kann der Befehl <a href="https://linux.die.net/man/1/chsh" target="_blank" rel="noopener noreferrer"><code>chsh</code></a> verwendet werden.
Manche Linux-Distributionen haben eine Liste von erlaubten Shells in <code>/etc/shells</code> und verbieten es die Shell zu Ã¤ndern, bis Nu in der Whitelist ist. Wenn die <code>shells</code>-Datei nicht abgeÃ¤ndert wurde, erscheint vielleicht einen Ã¤hnlichen Fehler, wie:</p>
<div><pre><code>chsh: /home/username/.cargo/bin/nu is an invalid shell
</code></pre></div><p>Nu kann zur Liste der erlaubte Shells hinzugefÃ¼gt werden, indem der Pfad von <code>nu</code> der <code>shells</code>-Datei angefÃ¼gt wird.
Der Pfad, der hinzugefÃ¼gt werden muss, kann mit dem Befehl <code>which nu</code> herausgefunden werden. Normalerweise ist es <code>$HOME/.cargo/bin/nu</code>.</p>
]]></content>
  </entry>
  <entry>
    <title type="html">Konfiguration</title>
    <id>www.nushell.sh/de/book/konfiguration.html</id>
    <link href="www.nushell.sh/de/book/konfiguration.html"/>
    <updated>2022-06-03T13:51:58.408Z</updated>
    <content type="html"><![CDATA[<h1 id="konfiguration" tabindex="-1"> Konfiguration</h1>
<h2 id="nushell-konfiguration-mittels-config-nu" tabindex="-1"> Nushell Konfiguration mittels <code>config.nu</code></h2>
<p>Nushell nutzt ein Konfigurationssystem, das ein Nushell-Skript beim Start ausfÃ¼hrt. Die Konfigurationsdatei wird fÃ¼r Nushell <code>config.nu</code> genannt. Der Pfad zu dieser Konfigurationsdatei kann durch den Aufruf von <code>echo $nu.config-path</code> herausgefunden werden. Es handelt sich dabei um eine Datei, die abgearbeitet wird und in jedem Schritt Definitionen, Umgebungsvariablen und mehr zum globalen Namespace hinzufÃ¼gt.</p>
<p>Ein Beispiel fÃ¼r eine Nushell <code>config.nu</code> kann <a href="https://github.com/nushell/nushell/blob/main/src/default_config.nu" target="_blank" rel="noopener noreferrer">hier</a> in unserem Repository gefunden werden.</p>
<h3 id="config-konfigurieren" tabindex="-1"> <code>$config</code> konfigurieren</h3>
<p>Die zentralen Konfigurationen von Nushell sind in der globalen <code>$config</code> Variable festgehalten. Dieser Eintrag kann wie folgt erstellt werden:</p>
<div><pre><code>let $config = {
  ...
}
</code></pre></div><p>Es ist auch mÃ¶glich <code>$config</code> zu Ã¼berschreiben und zu Ã¤ndern:</p>
<div><pre><code>let $config = ($config | update &lt;field name> &lt;field value>)
</code></pre></div><h3 id="umgebung" tabindex="-1"> Umgebung</h3>
<p>Die Shell-Umgebung kann durch Aufrufe von <code>let-env</code> in der <code>config.nu</code>-Datei geÃ¤ndert werden. Es gibt einige wichtige Nushell-spezifischen Einstellungen:</p>
<ul>
<li><code>LS_COLORS</code>: Setzt die Farben fÃ¼r Dateitypen in ls</li>
<li><code>PROMPT_COMMAND</code>: Befehle, die ausgefÃ¼hrt werden, um die Prompt zu erzeugen (Block oder String)</li>
<li><code>PROMPT_COMMAND_RIGHT</code>: Befehle, die ausgefÃ¼hrt werden, um die Prompt zu erzeugen (Block)</li>
<li><code>PROMPT_INDICATOR = &quot;ã€‰&quot;</code>: Indikator, der der Prompt folgt (default: &quot;&gt;&quot;-like Unicode symbol)</li>
<li><code>PROMPT_INDICATOR_VI_INSERT = &quot;: &quot;</code></li>
<li><code>PROMPT_INDICATOR_VI_NORMAL = &quot;ã€‰ &quot;</code></li>
<li><code>PROMPT_MULTILINE_INDICATOR = &quot;::: &quot;</code></li>
</ul>
<h3 id="farbkonfiguration" tabindex="-1"> Farbkonfiguration</h3>
<p>Mehr Informationen zu Farbeinstellungen und Themes kann im <a href="/book/coloring_and_theming.html">entsprechenden Kapitel</a> gefunden werden.</p>
<h2 id="nushell-als-login-shell" tabindex="-1"> Nushell als Login-Shell</h2>
<p>Um Nushell als Login-Shell zu verwenden, muss die <code>$env</code> Variable konfiguriert werden, damit es mÃ¶glich ist, externe Befehle als Login-Shell auszufÃ¼hren.</p>
<p>Der komplette Satz an Umgebungsvariablen kann erzeugt werden, wenn Nu in einer anderen Shell, wie beispielsweise Bash, ausgefÃ¼hrt wird. In diese Nu-Sitzung kann ein Befehl wie der folgende verwendet werden, um <code>$env</code> zu setzen:</p>
<div><pre><code>> env | each { echo $"let-env ($it.name) = '($it.raw)'" } | str collect (char nl)
</code></pre></div><p>Das wird <code>let-env</code> Zeilen ausgeben - eine fÃ¼r jede Umgebungsvariable - inklusive der nÃ¶tigen Werte.</p>
<p>Als nÃ¤chstes, muss auf manchen Distributionen sichergestellt werden, dass Nu in der Liste der Shells in /etc/shells ist:</p>
<div><pre><code>> cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash
/bin/rbash
/usr/bin/screen
/usr/bin/fish
/home/jonathan/.cargo/bin/nu
</code></pre></div><p>Damit sollte es mÃ¶glich sein, Nu als Login-Shell mit <code>chsh</code> festzulegen. Nach dem Ausloggen und erneutem Einloggen sollte Nu als Shell grÃ¼ÃŸen.</p>
<h3 id="macos-usr-bin-open-als-open-behalten" tabindex="-1"> macOS: <code>/usr/bin/open</code> als <code>open</code> behalten</h3>
<p>Manche Tools (z.B. Emacs) vertrauen darauf, dass <code>open</code> Dateien auf dem Mac Ã¶ffnet.
Da Nushell einen eigenen <code>open</code> Befehl hat, der eine andere Semantik hat und <code>/usr/bin/open</code> verbirgt, werden diese Tools einen Fehler werfen, wenn sie verwendet werden.
Eine MÃ¶glichkeit, dieses Problem zu umgehen, ist es, einen eigenen Befehl und einen <code>alias</code> in <code>config.nu</code> zu definieren:</p>
<div><pre><code>def nuopen [arg, --raw (-r)] { if $raw { open -r $arg } else { open $arg } }
alias open = ^open
</code></pre></div><h2 id="konfiguration-der-prompt" tabindex="-1"> Konfiguration der Prompt</h2>
<p>Die Konfiguration der Prompt wird durch das Setzen der Umgebungsvariable <code>PROMPT_COMMAND</code> bzw. <code>PROMPT_COMMAND_RIGHT</code> durchgefÃ¼hrt.
Diese akzeptieren entweder einen String oder einen Codeblock der ausgefÃ¼hrt wird.</p>
<div><pre><code>let-env PROMPT_COMMAND = "Hallo Nu"  # Die Hauptprompt auf einen festen String setzen
let-env PROMPT_COMMAND_RIGHT = {pwd} # Den rechte Promptteil mit dem aktuellen Verzeichnis anzeigen
</code></pre></div><p>DarÃ¼ber hinaus wird als Markierung ein Promptindikator gesetzt, welcher den aktuellen Modus oder einen Zeilenumbruch anzeigt:</p>
<ul>
<li><code>PROMPT_INDICATOR = &quot;ã€‰&quot;</code>: Indikator, der der Prompt folgt (default: &quot;&gt;&quot;-like Unicode symbol)</li>
<li><code>PROMPT_INDICATOR_VI_INSERT = &quot;: &quot;</code></li>
<li><code>PROMPT_INDICATOR_VI_NORMAL = &quot;ã€‰ &quot;</code></li>
<li><code>PROMPT_MULTILINE_INDICATOR = &quot;::: &quot;</code></li>
</ul>
<p>Mehr Dokumentation zu fertigen Prompts von Drittanbietern kann <a href="/de/book/3rdpartyprompts.html">hier</a> gefunden werden.</p>
]]></content>
  </entry>
  <entry>
    <title type="html">Mathematik</title>
    <id>www.nushell.sh/de/book/mathematik.html</id>
    <link href="www.nushell.sh/de/book/mathematik.html"/>
    <updated>2022-06-03T13:51:58.408Z</updated>
    <content type="html"><![CDATA[<h1 id="mathematik" tabindex="-1"> Mathematik</h1>
<p>Manchmal mÃ¼ssen lediglich ein paar Zahlen addiert werden, um eine Aufgabe zu erledigen. Nushell bietet dazu einen Satz an grundlegenden mathematischen Funktionen an. Mathematische AusdrÃ¼cke sind Ã¼berall dort verfÃ¼gbar, wo ein Befehl aufgerufen werden kann.</p>
<h2 id="addieren-subtrahieren-multiplizieren-dividieren" tabindex="-1"> Addieren, Subtrahieren, Multiplizieren, Dividieren</h2>
<div><pre><code>> 1 + 3
4
</code></pre></div><p>In Nushell, kÃ¶nnen die Operationen Addition, Subtraktion, Multiplikation und Division mit den dafÃ¼r Ã¼blichen Symbolen <code>+</code>, <code>-</code>, <code>*</code> und <code>/</code> aufgerufen werden. Die Reihenfolge der Operatoren wird dabei berÃ¼cksichtigt. Ein Beispiel: <code>1 + 2 * 3</code> wird behandelt als <code>1 + (2 * 3)</code>. Was zum nÃ¤chsten Konzept fÃ¼hrt: Klammern.</p>
<h2 id="klammern" tabindex="-1"> Klammern</h2>
<p>Klammern kÃ¶nnen verwendet werden, um mathematische AusdrÃ¼cke zu gruppieren. Das erlaubt es <code>(1 + 2) * 3</code> zu verwenden, um beispielsweise die Addition vor der Multiplikation auszufÃ¼hren.</p>
<h2 id="in-und-not-in" tabindex="-1"> <code>in</code> und <code>not-in</code></h2>
<p>Um herauszufinden, ob ein Wert in einem Datensatz ist oder nicht, kÃ¶nnen die Operatoren <code>in</code> und <code>not-in</code> verwendet werden.</p>
<div><pre><code>> 1 in [1 2 3]
true
</code></pre></div><div><pre><code>> 1 not-in [1 2 3]
false
</code></pre></div><h2 id="und" tabindex="-1"> =~ und !~</h2>
<p>Um zu Ã¼berprÃ¼fen, ob ein String innerhalb eines anderen Strings zu finden ist oder nicht, kÃ¶nnen die Operatoren <code>=~</code> und <code>!~</code> verwendet werden.</p>
<div><pre><code>> "foobar" =~ "foo"
true
</code></pre></div><div><pre><code>> "foobar" !~ "baz"
true
</code></pre></div><h2 id="vergleiche" tabindex="-1"> Vergleiche</h2>
<p>Die folgenden Vergleichsoperatoren sind ebenfalls verfÃ¼gbar:</p>
<ul>
<li><code>&lt;</code> - kleiner als</li>
<li><code>&lt;=</code> - kleiner gleich</li>
<li><code>&gt;</code> - grÃ¶ÃŸer als</li>
<li><code>&gt;=</code> - grÃ¶ÃŸer gleich</li>
<li><code>==</code> - gleich</li>
<li><code>!=</code> - ungleich</li>
</ul>
<h2 id="verknupfungsoperatoren" tabindex="-1"> VerknÃ¼pfungsoperatoren</h2>
<p>Nushell unterstÃ¼tzt auch die Operatoren <code>&amp;&amp;</code> (&quot;und&quot;) und <code>||</code> (&quot;oder&quot;) um zwei Operationen die Bool-Werte zurÃ¼ckgeben zu verbinden. Zum Beispiel: <code>ls | where name in [&quot;one&quot; &quot;two&quot; &quot;three&quot;] &amp;&amp; size &gt; 10kb</code></p>
<h2 id="reihenfolge-von-operationen" tabindex="-1"> Reihenfolge von Operationen</h2>
<p>Mathematische Operationen werden in der folgenden Reihenfolge ausgewertet (von der hÃ¶chsten PrioritÃ¤t zur niedrigsten PrioritÃ¤t):</p>
<ul>
<li>Klammern (<code>()</code>)</li>
<li>Multiplikation (<code>*</code>), Division (<code>/</code>) und Potenz (<code>**</code>)</li>
<li>Addition (<code>+</code>) und Subtraktion (<code>-</code>)</li>
</ul>
<div><pre><code>> 3 * (1 + 2)
9
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Plugins</title>
    <id>www.nushell.sh/de/book/plugins.html</id>
    <link href="www.nushell.sh/de/book/plugins.html"/>
    <updated>2022-06-03T13:51:58.408Z</updated>
    <content type="html"><![CDATA[<h1 id="plugins" tabindex="-1"> Plugins</h1>
<p>Die Funktionen von Nushell kÃ¶nnen mittels Plugins erweitert werden. Diese Plugins kÃ¶nnen einen GroÃŸteil der selben Operationen ausfÃ¼hren, wie die internen Befehle. Noch dazu haben Plugins den Vorteil, dass sie separat und flexibel zu Nushell hinzugefÃ¼gt werden kÃ¶nnen.</p>
<p>Um ein Plugin hinzuzufÃ¼gen, muss es erstellt werden und dann der Befehl <code>register</code> auf dieses Plugin aufgerufen werden. Wenn das getan wird, muss Nushell auch mitgeteilt werden, welches Protokoll vom Plugin verwendet wird.</p>
<p>Ein Beispiel:</p>
<div><pre><code>> register ./my_plugins/nu-plugin-inc -e capnp
</code></pre></div><p>Wenn der Befehl registriert wurde, kann er als Teil der internen Befehle verwendet werden.</p>
<div><pre><code>> inc --help
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Variablen und UnterausdrÃ¼cke</title>
    <id>www.nushell.sh/de/book/variablen_und_unterausdruecke.html</id>
    <link href="www.nushell.sh/de/book/variablen_und_unterausdruecke.html"/>
    <updated>2022-06-03T13:51:58.408Z</updated>
    <content type="html"><![CDATA[<h1 id="variablen-und-unterausdrucke" tabindex="-1"> Variablen und UnterausdrÃ¼cke</h1>
<p>Es gibt zwei Arten von auszuwertenden AusdrÃ¼cken in Nushell: Variablen und UnterausdrÃ¼cke. Diese werden durch das Dollar Symbol (<code>$</code>) eingeleitet. Das gibt den Hinweis, dass Nushell an dieser Stelle einen Ausdruck auswerten muss, um einen Wert zu erhalten, der fÃ¼r die AusfÃ¼hrung eines gesamten Befehls benÃ¶tigt wird. Beide Formen des Ausdrucks haben eine einfache Variante und eine 'Pfad'-Variante, wenn mit komplexeren Daten gearbeitet wird.</p>
<h2 id="variablen" tabindex="-1"> Variablen</h2>
<p>Die einfachere Variante der auszuwertenden AusdrÃ¼cke ist die Variable. WÃ¤hrend der Auswertung, wird die Variable durch ihren Wert ersetzt.</p>
<p>Wenn eine Variable erzeugt wurde, kann der Inhalt dieser Variable ausgegeben werden, indem <code>$</code> vor dem Variablennamen verwendet wird:</p>
<div><pre><code>> let my-value = 4
> echo $my-value
4
</code></pre></div><h2 id="pfade-von-variablen" tabindex="-1"> Pfade von Variablen</h2>
<p>Ein Pfad einer Variable funktioniert Ã¤hnlich wie ein strukturierter Datentyp. Es kann mittels Referenzen auf den Inhalt der Variable beziehungsweise die Spalten in der Variable zugegriffen werden, um final bei einem bestimmten Wert zu landen. Wenn beispielsweise anstatt der <code>4</code> im obigen Beispiel, der Variablen eine Tabelle zugewiesen wurde:</p>
<div><pre><code>> let my-value = [[name]; [testuser]]
</code></pre></div><p>Hier kann ein Pfad der Variable <code>$my-value</code> verwendet werden, um den Wert der Spalte <code>name</code> in nur einem Schritt zu bekommen:</p>
<div><pre><code>> echo $my-value.name
testuser
</code></pre></div><h2 id="unterausdrucke" tabindex="-1"> UnterausdrÃ¼cke</h2>
<p>UnterausdrÃ¼cke kÃ¶nnen jederzeit ausgewertet und die Ergebnisse verwendet werden, indem der Ausdruck in Klammern <code>()</code> gepackt wird. Hinweis: In Ã¤lteren Versionen von Nushell (Ã¤lter als 0.32) wurde <code>$()</code> benutzt.</p>
<p>Die Klammern enthalten eine Pipeline, die bis zum Ende durchlaufen wird und deren Ergebnis dann verwendet wird. Hier einige Beispiele: <code>(ls)</code> wÃ¼rde den <code>ls</code> Befehl ausfÃ¼hren und die entsprechende Tabelle zurÃ¼ckgeben und <code>(git branch --show-current)</code> fÃ¼hrt den externen Befehl <code>git</code> aus und gibt einen String mit dem Namen des aktuellen Branch zurÃ¼ck. Diese Klammern kÃ¶nnen auch verwendet werden, um mathematische AusdrÃ¼cke, wie <code>(2 + 3)</code>, auszuwerten.</p>
<p>UnterausdrÃ¼cke kÃ¶nnen auch ganze Pipelines statt nur einzelner Befehle enthalten. Um eine Liste von Dateien mit einer GrÃ¶ÃŸe grÃ¶ÃŸer als 10 Kilobytes zu bekommen, kann die folgende Pipeline verwendet und einer Variable zugewiesen werden:</p>
<div><pre><code>> let names-of-big-files = (ls | where size > 10kb)
> echo $names-of-big-files
â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 # â”‚    name    â”‚ type â”‚   size   â”‚   modified
â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 0 â”‚ Cargo.lock â”‚ File â”‚ 155.3 KB â”‚ 17 hours ago
 1 â”‚ README.md  â”‚ File â”‚  15.9 KB â”‚ 17 hours ago
â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
</code></pre></div><h2 id="unterausdrucke-und-pfade" tabindex="-1"> UnterausdrÃ¼cke und Pfade</h2>
<p>UnterausdrÃ¼cke unterstÃ¼tzen auch Pfade. Um beispielsweise eine Liste der Dateinamen im aktuellen Ordner zu bekommen, kann diese Pipeline verwendet werden:</p>
<div><pre><code>> ls | get name
</code></pre></div><p>Dasselbe Ergebnis kann auch in nur einem Schritt erreicht werden, indem ein Unterausdruck mit Pfad verwendet wird:</p>
<div><pre><code>> echo (ls).name
</code></pre></div><p>Welcher Stil gewÃ¤hlt wird, hÃ¤ngt vom Anwendungsfall und den persÃ¶nlichen Vorlieben ab.</p>
<h2 id="short-hand-unterausdrucke" tabindex="-1"> Short-hand UnterausdrÃ¼cke</h2>
<p>Nushell erlaubt den Zugriff auf Spalten in Tabellen in UnterausdrÃ¼cken durch einfache Short-Hands. Wenn beispielsweise nur Zeilen in <code>ls</code> angezeigt werden sollen, in der die GrÃ¶ÃŸe der Datei grÃ¶ÃŸer als 10 Kilobytes ist, kann der folgende Befehl verwendet werden:</p>
<div><pre><code>> ls | where size > 10kb
</code></pre></div><p><code>where size &gt; 10kb</code> ist ein Befehl mit zwei Teilen: Dem Befehlsnamen <code>where</code> und dem short-hand Ausdruck <code>size &gt; 10kb</code>. Hier wird auch klar, warum das Ganze short-hand heiÃŸt: <code>size</code> ist hier die gekÃ¼rzte Version von <code>$it.size</code>. Das Ganze kÃ¶nnte auch mit einer der folgenden ausfÃ¼hrlicheren Varianten erreicht werden:</p>
<div><pre><code>> ls | where $it.size > 10kb
> ls | where ($it.size > 10kb)
> ls | where {|$it| $it.size > 10kb }
</code></pre></div><p>Damit diese short-hand Syntax funktioniert, muss der Name der Spalte auf der linken Seite der Operation sein (wie bei <code>size</code> in <code>size &gt; 10kb</code>).</p>
]]></content>
  </entry>
  <entry>
    <title type="html">Vergleich zu Bash</title>
    <id>www.nushell.sh/de/book/von_bash_kommend.html</id>
    <link href="www.nushell.sh/de/book/von_bash_kommend.html"/>
    <updated>2022-06-03T13:51:58.409Z</updated>
    <content type="html"><![CDATA[<h1 id="vergleich-zu-bash" tabindex="-1"> Vergleich zu Bash</h1>
<p>Hinweis: Diese Tabelle geht von Nu 0.59 oder neuer aus.</p>
<table>
<thead>
<tr>
<th>Bash</th>
<th>Nu</th>
<th>Funktion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls</code></td>
<td><code>ls</code></td>
<td>Auflisten der Dateien des aktuellen Pfads</td>
</tr>
<tr>
<td><code>ls &lt;dir&gt;</code></td>
<td><code>ls &lt;dir&gt;</code></td>
<td>Auflisten der Dateien am angegebenen Pfad</td>
</tr>
<tr>
<td><code>ls pattern*</code></td>
<td><code>ls pattern*</code></td>
<td>Auflisten von Dateien, die dem gegebenen Schema/Pattern folgen</td>
</tr>
<tr>
<td><code>ls -la</code></td>
<td><code>ls --long --all</code> or <code>ls -la</code></td>
<td>Auflisten aller Dateien (inklusive versteckte) mit allen verfÃ¼gbaren Informationen</td>
</tr>
<tr>
<td><code>ls -d */</code></td>
<td><code>ls | where type == Dir</code></td>
<td>Auflisten von Ordnern</td>
</tr>
<tr>
<td><code>find . -name *.rs</code></td>
<td><code>ls **/*.rs</code></td>
<td>Rekursives auflisten aller Dateien, die zum gegebenen Schema/Pattern passen</td>
</tr>
<tr>
<td><code>cd &lt;directory&gt;</code></td>
<td><code>cd &lt;directory&gt;</code></td>
<td>Wechseln an den angegebenen Pfad</td>
</tr>
<tr>
<td><code>cd</code></td>
<td><code>cd</code></td>
<td>Wechseln in den HOME-Ordner</td>
</tr>
<tr>
<td><code>cd -</code></td>
<td><code>cd -</code></td>
<td>Wechseln an den vorherigen Pfad</td>
</tr>
<tr>
<td><code>mkdir &lt;path&gt;</code></td>
<td><code>mkdir &lt;path&gt;</code></td>
<td>Erzeugen des angegebenen Pfads</td>
</tr>
<tr>
<td><code>mkdir -p &lt;path&gt;</code></td>
<td><code>mkdir &lt;path&gt;</code></td>
<td>Erzeugen des angegebenen Pfads und weiterer Ordner wenn nÃ¶tig</td>
</tr>
<tr>
<td><code>touch test.txt</code></td>
<td><code>touch test.txt</code></td>
<td>Erstellen einer Datei</td>
</tr>
<tr>
<td><code>&gt; &lt;path&gt;</code></td>
<td><code>| save &lt;path&gt;</code></td>
<td>Speichern eines String in eine Datei</td>
</tr>
<tr>
<td><code>&gt;&gt; &lt;path&gt;</code></td>
<td><code>| save --append &lt;path&gt;</code></td>
<td>AnhÃ¤ngen eines Strings an eine Datei</td>
</tr>
<tr>
<td><code>cat &lt;path&gt;</code></td>
<td><code>open --raw &lt;path&gt;</code></td>
<td>Einlesen des Inhalts der angegebenen Datei (in Textform)</td>
</tr>
<tr>
<td></td>
<td><code>open &lt;path&gt;</code></td>
<td>Einlesen einer Datei in Form von strukturierten Daten</td>
</tr>
<tr>
<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>
<td>Bewegen einer Datei an einen neuen Ort</td>
</tr>
<tr>
<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>
<td>Kopieren einer Datei an einen Ort</td>
</tr>
<tr>
<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>
<td>Kopieren eines Ordners an einen Ort (rekursiv)</td>
</tr>
<tr>
<td><code>rm &lt;path&gt;</code></td>
<td><code>rm &lt;path&gt;</code></td>
<td>Entfernen der angegebenen Datei</td>
</tr>
<tr>
<td></td>
<td><code>rm -t &lt;path&gt;</code></td>
<td>Angegebene Datei in den Papierkorb des Systems werfen</td>
</tr>
<tr>
<td><code>rm -rf &lt;path&gt;</code></td>
<td><code>rm -r &lt;path&gt;</code></td>
<td>Entfernen des angegebenen Pfads rekursiv</td>
</tr>
<tr>
<td><code>chmod</code></td>
<td><code>&lt;Noch nicht mÃ¶glich&gt;</code></td>
<td>Ã„ndern von Dateiattributen</td>
</tr>
<tr>
<td><code>date -d &lt;date&gt;</code></td>
<td><code>&quot;&lt;date&gt;&quot; | into datetime -f &lt;format&gt;</code></td>
<td>Datum ausgeben (<a href="https://docs.rs/chrono/0.4.15/chrono/format/strftime/index.html" target="_blank" rel="noopener noreferrer">Dokumentation des Formats</a>)</td>
</tr>
<tr>
<td><code>sed</code></td>
<td><code>str find-replace</code></td>
<td>Suchen und ersetzen eines Pattern in einem String</td>
</tr>
<tr>
<td><code>grep &lt;pattern&gt;</code></td>
<td><code>where $it =~ &lt;substring&gt;</code> or <code>find &lt;substring&gt;</code></td>
<td>Filtern von Strings die den Substring beinhalten</td>
</tr>
<tr>
<td><code>man &lt;command&gt;</code></td>
<td><code>help &lt;command&gt;</code></td>
<td>Hilfe zu einem Befehl ansehen</td>
</tr>
<tr>
<td></td>
<td><code>help commands</code></td>
<td>Alle verfÃ¼gbaren Befehle anzeigen</td>
</tr>
<tr>
<td></td>
<td><code>help --find &lt;string&gt;</code></td>
<td>Nach einem Text in allen verfÃ¼gbaren Befehlen suchen</td>
</tr>
<tr>
<td><code>command1 &amp;&amp; command2</code></td>
<td><code>command1; command2</code></td>
<td>AusfÃ¼hren eines Befehls und wenn AusfÃ¼hrung erfolgreich wird ein weiterer Befehl ausgefÃ¼hrt</td>
</tr>
<tr>
<td><code>stat $(which git)</code></td>
<td><code>stat (which git).path</code></td>
<td>Ausgabe eines Befehls als Eingabe fÃ¼r einen anderen Befehl verwenden</td>
</tr>
<tr>
<td><code>echo $PATH</code></td>
<td><code>echo $env.PATH</code></td>
<td>Aktuelle PATH-Variable anzeigen</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>vim $nu.config-path</code></td>
<td>PATH permanent Ã¤ndern</td>
</tr>
<tr>
<td><code>export PATH = $PATH:/usr/other/bin</code></td>
<td><code>let-env PATH = ($env.PATH | append /usr/other/bin)</code></td>
<td>PATH temporÃ¤r Ã¤ndern</td>
</tr>
<tr>
<td><code>export</code></td>
<td><code>echo $env</code></td>
<td>Anzeigen der aktuellen Umgebungsvariablen</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>vim $nu.config-path</code></td>
<td>Umgebungsvariablen permanent Ã¤ndern</td>
</tr>
<tr>
<td><code>FOO=BAR ./bin</code></td>
<td><code>FOO=BAR ./bin</code></td>
<td>Umgebungsvariablen temporÃ¤r Ã¤ndern</td>
</tr>
<tr>
<td><code>export FOO=BAR</code></td>
<td><code>let-env FOO = BAR</code></td>
<td>Umgebungsvariable fÃ¼r aktuelle Sitzung setzen</td>
</tr>
<tr>
<td><code>echo $FOO</code></td>
<td><code>echo $env.FOO</code></td>
<td>Umgebungsvariablen nutzen</td>
</tr>
<tr>
<td><code>unset FOO</code></td>
<td><code>hide FOO</code></td>
<td>Umgebungsvariable fÃ¼r aktuelle Sitzung verbergen</td>
</tr>
<tr>
<td><code>alias s=&quot;git status -sb&quot;</code></td>
<td><code>alias s = git status -sb</code></td>
<td>Alias temporÃ¤r definieren</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>vim $nu.config-path</code></td>
<td>Alias permanent hinzufÃ¼gen und Ã¤ndern (fÃ¼r neue Shells)</td>
</tr>
<tr>
<td><code>bash -c &lt;commands&gt;</code></td>
<td><code>nu -c &lt;commands&gt;</code></td>
<td>AusfÃ¼hren einer Pipeline an Befehlen (benÃ¶tigt 0.9.1 oder neuer)</td>
</tr>
<tr>
<td><code>bash &lt;script file&gt;</code></td>
<td><code>nu &lt;script file&gt;</code></td>
<td>AusfÃ¼hren einer Skriptdatei (benÃ¶tigt 0.9.1 oder neuer)</td>
</tr>
<tr>
<td><code>\</code></td>
<td><code>(</code> gefolgt von <code>)</code></td>
<td>Fortsetzen von Zeilen</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
</feed>
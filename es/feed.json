{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Nushell",
  "home_page_url": "www.nushell.sh/es/",
  "feed_url": "www.nushell.sh/feed.json",
  "description": "Un nuevo tipo de shell.",
  "items": [
    {
      "title": "IntroducciÃ³n",
      "url": "www.nushell.sh/es/book/",
      "id": "www.nushell.sh/es/book/",
      "content_html": "<h1 id=\"introduccion\" tabindex=\"-1\"> IntroducciÃ³n</h1>\n<p>Hola, y bienvenido al proyecto Nushell. El objetivo de este proyecto es tomar la filosofÃ­a Unix de shells, dÃ³nde tuberÃ­as <em>-pipes-</em> conectan comandos simples juntos y llevarlos al estilo moderno de desarrollo.</p>\n<p>Nu toma ideas de muchos territorios familiares: shells tradicionales como bash, shells basadas en objetos como PowerShell, programaciÃ³n funcional, programaciÃ³n de sistemas, y mÃ¡s. Pero, en lugar de ser un &quot;Todo en uno&quot;, Nu enfoca su energÃ­a en hacer algunas cosas bien:</p>\n<ul>\n<li>Crear una multiplataforma shell flexible con un toque moderno.</li>\n<li>Permitir mezclar y combinar aplicaciones de lÃ­nea de comandos con una shell que entiende la estructura de sus datos.</li>\n<li>Tenga el brillo UX que proporcionan las aplicaciones modernas CLI.</li>\n</ul>\n<p>La manera mÃ¡s facil de ver quÃ© puede hacer Nu es con ejemplos, iniciemos.</p>\n<p>Lo primero que notarÃ¡s al ejercutar un comando como <code>ls</code> es que en lugar de un bloque de texto que regresa, recibirÃ¡s una tabla estructurada.</p>\n<div><pre><code><span>></span> <span>ls</span>\nâ•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ <span>#  â”‚         name          â”‚ type â”‚   size    â”‚  modified   â”‚</span>\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  <span>0</span> â”‚ <span>404</span>.html              â”‚ <span>file</span> â”‚     <span>429</span> B â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>1</span> â”‚ CONTRIBUTING.md       â”‚ <span>file</span> â”‚     <span>955</span> B â”‚ <span>8</span> mins ago  â”‚\nâ”‚  <span>2</span> â”‚ Gemfile               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>3</span> â”‚ Gemfile.lock          â”‚ <span>file</span> â”‚   <span>6.9</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>4</span> â”‚ LICENSE               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>5</span> â”‚ README.md             â”‚ <span>file</span> â”‚     <span>213</span> B â”‚ <span>3</span> days ago  â”‚\n<span>..</span>.\n</code></pre></div><p>La tabla no solamente muestra lo que hay en el directorio de una manera distinta sino algo mÃ¡s. Como las tablas de una hoja de cÃ¡lculo <em>-<em>spreadsheet</em>-</em>, esta tabla te permite trabajar con los datos mÃ¡s interactivamente.</p>\n<p>Lo primero que vamos hacer es ordenar nuestra tabla por tamaÃ±o. Para poder hacerlo tomaremos la salida de <code>ls</code> y la alimentaremos al comando que ordena tablas basado en los valores de una columna (para este ejemplo serÃ­a la columna <code>size</code>).</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> reverse\nâ•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ <span>#  â”‚         name          â”‚ type â”‚   size    â”‚  modified   â”‚</span>\nâ”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  <span>0</span> â”‚ Gemfile.lock          â”‚ <span>file</span> â”‚   <span>6.9</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>1</span> â”‚ SUMMARY.md            â”‚ <span>file</span> â”‚   <span>3.7</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>2</span> â”‚ Gemfile               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>3</span> â”‚ LICENSE               â”‚ <span>file</span> â”‚   <span>1.1</span> KiB â”‚ <span>3</span> days ago  â”‚\nâ”‚  <span>4</span> â”‚ CONTRIBUTING.md       â”‚ <span>file</span> â”‚     <span>955</span> B â”‚ <span>9</span> mins ago  â”‚\nâ”‚  <span>5</span> â”‚ books.md              â”‚ <span>file</span> â”‚     <span>687</span> B â”‚ <span>3</span> days ago  â”‚\n<span>..</span>.\n</code></pre></div><p>Puedes observar que para lograrlo no tuvimos que pasar argumentos al comando <code>ls</code>. En cambio, nosotros usamos el comando <code>sort-by</code> que proporciona Nu para ordenar la salida del comando <code>ls</code>. Para ver los archivos mÃ¡s grandes en las primeras filas usamos el comando <code>reverse</code>.</p>\n<p>Nu proporciona muchos comandos que trabajan con tablas. Por ejemplo, podemos filtrar los contenidos de la tabla de <code>ls</code> para Ãºnicamente mostrar archivos superiores a 1 kilobytes:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 1kb\nâ•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ <span># â”‚       name        â”‚ type â”‚  size   â”‚  modified  â”‚</span>\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ <span>0</span> â”‚ Gemfile           â”‚ <span>file</span> â”‚ <span>1.1</span> KiB â”‚ <span>3</span> days ago â”‚\nâ”‚ <span>1</span> â”‚ Gemfile.lock      â”‚ <span>file</span> â”‚ <span>6.9</span> KiB â”‚ <span>3</span> days ago â”‚\nâ”‚ <span>2</span> â”‚ LICENSE           â”‚ <span>file</span> â”‚ <span>1.1</span> KiB â”‚ <span>3</span> days ago â”‚\nâ”‚ <span>3</span> â”‚ SUMMARY.md        â”‚ <span>file</span> â”‚ <span>3.7</span> KiB â”‚ <span>3</span> days ago â”‚\nâ•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n</code></pre></div><p>Al igual que en la filosofÃ­a Unix, poder hacer que los comandos hablen entre ellos nos da maneras de mezclar y combinar de formas distintas. Miremos otro ejemplo:</p>\n<div><pre><code><span>></span> <span>ps</span>\nâ•­â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚  <span>#  â”‚ pid  â”‚         name         â”‚ status  â”‚  cpu  â”‚    mem    â”‚ virtual  â”‚</span>\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚   <span>0</span> â”‚ <span>7570</span> â”‚ nu                   â”‚ Running â”‚  <span>1.96</span> â”‚  <span>23.2</span> MiB â”‚ <span>32.8</span> GiB â”‚\nâ”‚   <span>1</span> â”‚ <span>3533</span> â”‚ remindd              â”‚ Sleep   â”‚  <span>0.00</span> â”‚ <span>103.6</span> MiB â”‚ <span>32.3</span> GiB â”‚\nâ”‚   <span>2</span> â”‚ <span>3495</span> â”‚ TVCacheExtension     â”‚ Sleep   â”‚  <span>0.00</span> â”‚  <span>11.9</span> MiB â”‚ <span>32.2</span> GiB â”‚\nâ”‚   <span>3</span> â”‚ <span>3490</span> â”‚ MusicCacheExtension  â”‚ Sleep   â”‚  <span>0.00</span> â”‚  <span>12.9</span> MiB â”‚ <span>32.2</span> GiB â”‚\n<span>..</span>.\n</code></pre></div><p>Es posible que estÃ©s familiarizado con el comando <code>ps</code> si has utilizado Linux. Con dicho comando, podemos tener una lista de los procesos actuales que ejecuta el sistema, quÃ© estado tienen y sus nombres. TambiÃ©n podemos ver la carga CPU del proceso.</p>\n<p>Â¿QuÃ© tal si quisiÃ©ramos mostrar los procesos que activamente usan el CPU? AsÃ­ como hicimos con el comando <code>ls</code> previamente, tambiÃ©n podemos trabajar con la tabla que nos devuelve <code>ps</code>:</p>\n<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>5</span>\nâ•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ <span># â”‚ pid  â”‚      name      â”‚ status  â”‚  cpu   â”‚    mem    â”‚ virtual  â”‚</span>\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ <span>0</span> â”‚ <span>1583</span> â”‚ Terminal       â”‚ Running â”‚  <span>20.69</span> â”‚ <span>127.8</span> MiB â”‚ <span>33.0</span> GiB â”‚\nâ”‚ <span>1</span> â”‚  <span>579</span> â”‚ photoanalysisd â”‚ Running â”‚ <span>139.50</span> â”‚  <span>99.9</span> MiB â”‚ <span>32.3</span> GiB â”‚\nâ•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n</code></pre></div><p>Hasta ahora, hemos visto el uso de <code>ls</code> y <code>ps</code> para enumerar archivos y procesos. Nu tambiÃ©n ofrece otros comandos que pueden crear tablas con informaciÃ³n de gran utilidad. Exploremos <code>date</code> y <code>sys</code>.</p>\n<p>Ejecutando <code>date now</code> nos proporciona informaciÃ³n del dÃ­a y tiempo:</p>\n<div><pre><code><span>></span> <span>date</span> now\n<span>2022</span>-03-07 <span>14</span>:14:51.684619600 -08:00\n</code></pre></div><p>Para obtener una tabla podemos alimentar la salida a <code>date to-table</code></p>\n<div><pre><code><span>></span> <span>date</span> now <span>|</span> <span>date</span> to-table\nâ•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ <span># â”‚ year â”‚ month â”‚ day â”‚ hour â”‚ minute â”‚ second â”‚ timezone â”‚</span>\nâ”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ <span>0</span> â”‚ <span>2022</span> â”‚     <span>3</span> â”‚   <span>7</span> â”‚   <span>14</span> â”‚     <span>45</span> â”‚      <span>3</span> â”‚ -08:00   â”‚\nâ•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n</code></pre></div><p>Ejecutando <code>sys</code> devuelve informaciÃ³n sobre el sistema en el que se ejecuta Nu:</p>\n<div><pre><code><span>></span> sys\nâ•­â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ <span>host</span>  â”‚ <span>{</span>record <span>6</span> fields<span>}</span> â”‚\nâ”‚ cpu   â”‚ <span>[</span>table <span>4</span> rows<span>]</span>    â”‚\nâ”‚ disks â”‚ <span>[</span>table <span>3</span> rows<span>]</span>    â”‚\nâ”‚ mem   â”‚ <span>{</span>record <span>4</span> fields<span>}</span> â”‚\nâ”‚ temp  â”‚ <span>[</span>table <span>1</span> row<span>]</span>     â”‚\nâ”‚ net   â”‚ <span>[</span>table <span>4</span> rows<span>]</span>    â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n</code></pre></div><p>Esta tabla se ve un poco diferente con las que ya hemos trabajado. El comando <code>sys</code> nos regresa una tabla que tambiÃ©n contiene tablas estructuradas en las celdas en vez de valores simples. Para explorar esos datos, necesitamos <em>obtener</em> la columna deseada para mostrar:</p>\n<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ name           â”‚ Debian GNU/Linux       â”‚\nâ”‚ os version     â”‚ <span>11</span>                     â”‚\nâ”‚ kernel version â”‚ <span>5.10</span>.92-v8+            â”‚\nâ”‚ <span>hostname</span>       â”‚ lifeless               â”‚\nâ”‚ <span>uptime</span>         â”‚ 19day 21hr 34min 45sec â”‚\nâ”‚ sessions       â”‚ <span>[</span>table <span>1</span> row<span>]</span>          â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\n</code></pre></div><p>El comando <code>get</code> nos permite ir directo al valor de una columa de la tabla. AquÃ­ estamos mirando la columna &quot;host&quot; que contiene informaciÃ³n del host dÃ³nde se estÃ¡ ejecutando Nu. El nombre del sistema operativo, hostname, CPU, y mÃ¡s. Miremos los nombres de los usuarios en el sistema:</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name\nâ•­â”€â”€â”€â”¬â”€â”€â”€â”€â•®\nâ”‚ <span>0</span> â”‚ jt â”‚\nâ•°â”€â”€â”€â”´â”€â”€â”€â”€â•¯\n</code></pre></div><p>En este momento, solo hay un usuario en el sistema llamado &quot;jt&quot;. NotarÃ¡s que podemos pasar una ruta de columna <em>-<em>column path</em>-</em> y no Ãºnicamente el nombre de una columna. Nu tomarÃ¡ esta ruta de columna e irÃ¡ a los datos correspondientes en la tabla.</p>\n<p>Es posible que hayas notado algo mÃ¡s diferente tambiÃ©n. En lugar de tener una tabla de datos, tenemos solo un elemento individual: la cadena &quot;jt&quot;. Nu trabaja tanto con tabla de datos asÃ­ como cadenas. Cadenas son una parte importante de trabajar con comandos fuera de Nu.</p>\n<p>Miremos en acciÃ³n cÃ³mo funcionan las cadenas fuera de Nu. Tomaremos el ejemplo anterior y ejecutaremos el comando externo <code>echo</code> (el carÃ¡cter <code>^</code> le informa a Nu que no se desea usar el comando <em>interno</em> tambiÃ©n llamado <code>echo</code>):</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> ^echo <span>$it</span> <span>}</span>\njt\n</code></pre></div><p>Si esto se parece mucho a lo que tenÃ­amos antes, Â¡tienes buen ojo! Es similar, pero con una diferencia importante: hemos llamado <code>echo</code> con el valor que vimos antes. Esto nos permite pasar datos fuera de Nu a <code>echo</code> (o cualquier comando fuera de Nu, como <code>git</code> por ejemplo)</p>\n<p><em>Nota: Para texto de ayuda de los comandos internos de Nu, puedes descubrirlos con el comando <code>help</code></em>:</p>\n<div><pre><code><span>></span> <span>help</span> path\nExplore and manipulate paths.\n\nThere are three ways to represent a path:\n\n* As a path literal, e.g., <span>'/home/viking/spam.txt'</span>\n* As a structured path: a table with <span>'parent'</span>, <span>'stem'</span>, and <span>'extension'</span> <span>(</span>and\n* <span>'prefix'</span> on Windows<span>)</span> columns. This <span>format</span> is produced by the <span>'path parse'</span>\n  subcommand.\n* As an inner list of path parts, e.g., <span>'[[ / home viking spam.txt ]]'</span><span>.</span>\n  Splitting into parts is <span>done</span> by the <span><span>`</span>path <span>split</span><span>`</span></span> command.\n\nAll subcommands accept all three variants as an input. Furthermore, the <span>'path\njoin'</span> subcommand can be used to <span>join</span> the structured path or path parts back into\nthe path literal.\n\nUsage:\n  <span>></span> path\n\nSubcommands:\n  path <span>basename</span> - Get the final component of a path\n  path <span>dirname</span> - Get the parent directory of a path\n  path exists - Check whether a path exists\n  path <span>expand</span> - Try to <span>expand</span> a path to its absolute form\n  path <span>join</span> - Join a structured path or a list of path parts.\n  path parse - Convert a path into structured data.\n  path relative-to - Get a path as relative to another path.\n  path <span>split</span> - Split a path into parts by a separator.\n  path <span>type</span> - Get the <span>type</span> of the object a path refers to <span>(</span>e.g., file, dir, symlink<span>)</span>\n\nFlags:\n  -h, --help\n      Display this <span>help</span> message\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.688Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Aliases",
      "url": "www.nushell.sh/es/book/aliases.html",
      "id": "www.nushell.sh/es/book/aliases.html",
      "content_html": "<h1 id=\"aliases\" tabindex=\"-1\"> Aliases</h1>\n<p>La habilidad de Nu para componer tuberÃ­as largas permite tener bastante control de su sistema y datos, pero a costas de tipear mucho. SerÃ­a ideal que puedas grabar las tuberÃ­as bien elaboradas para hacer uso de esas las veces que quieras.</p>\n<p>AquÃ­ es donde aparecen los aliases.</p>\n<p>Un alias te permite crear un nombre corto para un bloque de comandos. Cuando se ejecuta el alias, es lo equivalente como si hayas tipeado el bloque de comandos.</p>\n<p>Ejemplo:</p>\n<div><pre><code>> alias ls-nombres [] { ls | select name }\n> ls-nombres\nâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n #  â”‚ name\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  0 â”‚ 404.html\n  1 â”‚ CONTRIBUTING.md\n  2 â”‚ Gemfile\n  3 â”‚ Gemfile.lock\n  4 â”‚ LICENSE\n</code></pre></div><h2 id=\"parametros\" tabindex=\"-1\"> ParÃ¡metros</h2>\n<p>TambiÃ©n pueden tomar parÃ¡metros opcionales que son pasadas al bloque. Cada parÃ¡metro se convierte en una variable en el bloque.</p>\n<div><pre><code>> alias decir [mensaje] { echo $mensaje }\n> decir \"Â¡hola!\"\nÂ¡hola!\n</code></pre></div><p>Puedes tener un nÃºmero arbitrario de estos argumentos. Cuando el usuario no proporciona un valor, la variable en el bloque evaulara a <code>Nothing</code> y serÃ¡ eliminada.</p>\n",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Cargando datos",
      "url": "www.nushell.sh/es/book/cargando_datos.html",
      "id": "www.nushell.sh/es/book/cargando_datos.html",
      "content_html": "<h1 id=\"cargando-datos\" tabindex=\"-1\"> Cargando datos</h1>\n<p>Hemos visto como puedes usar comandos como <code>ls</code>, <code>ps</code>, <code>date</code>, y <code>sys</code> para cargar informaciÃ³n sobre los archivos, procesos, hora de fecha, y del mismo sistema. Cada comando nos entrega una tabla de informaciÃ³n que podemos explorar. Hay otras maneras de cargar datos en una tabla de datos para trabajar.</p>\n<h2 id=\"abriendo-archivos\" tabindex=\"-1\"> Abriendo archivos</h2>\n<p>Una de las funciones mÃ¡s destacadas de Nu para trabajar con datos es el comando <code>open</code>. Es una multi-herramienta que puede trabajar con varios formatos de datos. Para ver quÃ© significa esto intentemos abrir un archivo en formato json:</p>\n<div><pre><code>> open editors/vscode/package.json\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n name | descript | author   | license | version | reposito | publishe | categori | keywords | engines  | activati | main     | contribu | scripts  | devDepen\n      | ion      |          |         |         | ry       | r        | es       |          |          | onEvents |          | tes      |          | dencies\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n lark | Lark     | Lark     | MIT     | 1.0.0   | [object] | vscode   | [0       | [1 item] | [object] | [1 item] | ./out/ex | [object] | [object] | [object]\n      | support  | develope |         |         |          |          | items]   |          |          |          | tension  |          |          |\n      | for VS   | rs       |         |         |          |          |          |          |          |          |          |          |          |\n      | Code     |          |         |         |          |          |          |          |          |          |          |          |          |\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n</code></pre></div><p>De manera similar a <code>ls</code>, abrir un tipo de archivo que Nu entienda nos devolverÃ¡ algo mÃ¡s que solo texto (o una secuencia de bytes). AquÃ­ abrimos el archivo &quot;package.json&quot; de un proyecto de JavaScript. Nu puede reconocer y abrir el texto en JSON y devolvernos una tabla de datos.</p>\n<p>Si deseamos revisar la versiÃ³n del proyecto que estamos mirando podemos usar el comando <code>get</code>.</p>\n<div><pre><code>> open editors/vscode/package.json | get version\n1.0.0\n</code></pre></div><p>Actualmente Nu soporta los siguiente formatos para cargar datos directamente a tablas:</p>\n<ul>\n<li>json</li>\n<li>yaml</li>\n<li>toml</li>\n<li>xml</li>\n<li>csv</li>\n<li>ini</li>\n</ul>\n<p>Â¿Pero quÃ© sucede si cargas un archivo de texto que no sea de estos? Probemos:</p>\n<div><pre><code>> open README.md\n</code></pre></div><p>Se nos muestra el contenido del archivo. Si el archivo es muy grande obtendremos una vista prÃ¡ctica desplazable para mirar el archivo y luego regresar a la terminal. Para ayudar con legibilidad Nu resaltarÃ¡ la sintaxis de formatos comunes de archivos como de cÃ³digo, markdown, y mÃ¡s.</p>\n<p>Debajo de la superficie Nu mira estos archivos de texto como una cadena larga. PrÃ³ximamente hablaremos de cÃ³mo trabajar con estas cadenas para extraer los datos que necesitemos de ellas.</p>\n<h2 id=\"trabajando-con-cadenas\" tabindex=\"-1\"> Trabajando con cadenas</h2>\n<p>Una parte importante de trabajar con datos llegando fuera de Nu es que no siempre estarÃ¡ en formato que Nu entiende. ComÃºnmente estos datos son proporcionados como una cadena.</p>\n<p>Imaginemos que nos proporcionan estos datos de archivo:</p>\n<div><pre><code>> open gente.txt\nOctavia | Butler | Writer\nBob | Ross | Painter\nAntonio | Vivaldi | Composer\n</code></pre></div><p>Cada pedazo de dato que deseamos estÃ¡ separada por el sÃ­mbolo de tuberÃ­a (pipe '|'), y cada persona estÃ¡ en lÃ­neas separadas. Nu no contiene un formato de archivo delimitado con pleca ('|') predeterminado, por lo que tendremos que parsearlo nosotros mismos.</p>\n<p>Lo primero que queremos hacer al cargar el archivo es trabajarlo lÃ­nea por lÃ­nea:</p>\n<div><pre><code>> open gente.txt | lines\n---+------------------------------\n # | value\n---+------------------------------\n 0 | Octavia | Butler | Writer\n 1 | Bob | Ross | Painter\n 2 | Antonio | Vivaldi | Composer\n---+------------------------------\n</code></pre></div><p>Podemos darnos cuenta que estamos trabajando con las lÃ­neas porque estamos de vuelta a una tabla. Nuestro prÃ³ximo paso es mirar si podemos dividir las filas a algo mÃ¡s Ãºtil. Para eso, usaremos el comando <code>split</code>. <code>split</code>, como implica el nombre, nos da una manera de dividir una cadena delimitada. Usaremos el subcomando <code>column</code> para dividir el contenido a varias columnas. Indicamos cuÃ¡l es el delimitador y se hace el resto:</p>\n<div><pre><code>> open gente.txt | lines | split column \"|\"\n---+----------+-----------+-----------\n # | Column1  | Column2   | Column3\n---+----------+-----------+-----------\n 0 | Octavia  |  Butler   |  Writer\n 1 | Bob      |  Ross     |  Painter\n 2 | Antonio  |  Vivaldi  |  Composer\n---+----------+-----------+-----------\n</code></pre></div><p>Casi se ve correcto. Parece que hay espacio extra ahÃ­. Cambiemos nuestro delimitador:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \"\n---+---------+---------+----------\n # | Column1 | Column2 | Column3\n---+---------+---------+----------\n 0 | Octavia | Butler  | Writer\n 1 | Bob     | Ross    | Painter\n 2 | Antonio | Vivaldi | Composer\n---+---------+---------+----------\n</code></pre></div><p>Nada mal. El comando <code>split</code> nos da datos que podemos usar. Adicionalmente nos crea nombres de columnas predeterminadas:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \" | get Column1\n---+---------\n # | value\n---+---------\n 0 | Octavia\n 1 | Bob\n 2 | Antonio\n---+---------\n</code></pre></div><p>TambiÃ©n podemos nombrar nuestras columnas en vez de usar nombres predeterminados:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \" primer_nombre apellido trabajo\n---+---------------+-----------+----------\n # | primer_nombre | apellido  | trabajo\n---+---------------+-----------+----------\n 0 | Octavia       | Butler    | Writer\n 1 | Bob           | Ross      | Painter\n 2 | Antonio       | Vivaldi   | Composer\n---+---------------+-----------+----------\n</code></pre></div><p>Ahora que tenemos nuestros datos en una tabla podemos usar todos los comandos que hemos usado en tablas antes:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \" primer_nombre apellido trabajo | sort-by primer_nombre\n---+---------------+-----------+----------\n # | primer_nombre | apellido  | trabajo\n---+---------------+-----------+----------\n 0 | Antonio       | Vivaldi   | Composer\n 1 | Bob           | Ross      | Painter\n 2 | Octavia       | Butler    | Writer\n---+---------------+-----------+----------\n</code></pre></div><p>Hay otros comandos que puedes usar para trabajar con cadenas:</p>\n<ul>\n<li>str</li>\n<li>lines</li>\n<li>size</li>\n</ul>\n<p>TambiÃ©n hay un conjunto de comandos auxiliares que podemos llamar si conocemos de antemano que los datos tienen una estructura que Nu deberÃ­a de entender. Por ejemplo, abramos un Rust archivo lock:</p>\n<div><pre><code>> open Cargo.lock\n# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\n[[package]]\nname = \"adhoc_derive\"\nversion = \"0.1.2\"\n</code></pre></div><p>The <code>from</code> command can be used for each of the structured data text formats that Nu can open and understand by passing it the supported format as a subcommand.</p>\n<p>El archivo &quot;Cargo.lock&quot; es un archivo en formato .toml pero la extensiÃ³n del archivo no es .toml. EstÃ¡ bien, podemos usar el comando <code>from</code> usando el subcomando <code>toml</code>:</p>\n<div><pre><code>> open Cargo.lock | from toml\n----------+-------------\n metadata | package\n----------+-------------\n [object] | [405 items]\n----------+-------------\n</code></pre></div><p>El comando <code>from</code> se puede usar para cada dato estructurado de formatos de texto que Nu pueda abrir y entender pasando el formato soportado como subcomando.</p>\n<h2 id=\"abriendo-en-modo-crudo\" tabindex=\"-1\"> Abriendo en modo crudo</h2>\n<p>Mientras es Ãºtil poder abrir un archivo e inmediatamente trabajar con una tabla de sus datos, esto no siempre es lo que deseas hacer. Para llegar al texto subyacente, el comando <code>open</code> puede tomar una bandera opcional:</p>\n<div><pre><code>> open Cargo.toml --raw\n[package]\nname = \"nu\"\nversion = \"0.1.3\"\nauthors = [\"Yehuda Katz &lt;wycats@gmail.com>\", \"Jonathan Turner &lt;jonathan.d.turner@gmail.com>\"]\ndescription = \"A shell for the GitHub era\"\nlicense = \"MIT\"\n</code></pre></div><h2 id=\"abriendo-urls\" tabindex=\"-1\"> Abriendo URLs</h2>\n<p>AdemÃ¡s de cargar archivos desde tu archivos de sistema, tambiÃ©n puedes usar el comando <code>fetch</code> proporcionando una URL. Se cargarÃ¡ el contenido de la URL por internet y devolverÃ¡:</p>\n<div><pre><code>> fetch http://www.andresrobalino.com/feed.xml\n----------\n rss\n----------\n [1 item]\n----------\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "ConfiguraciÃ³n",
      "url": "www.nushell.sh/es/book/configuracion.html",
      "id": "www.nushell.sh/es/book/configuracion.html",
      "content_html": "<h1 id=\"configuracion\" tabindex=\"-1\"> ConfiguraciÃ³n</h1>\n<p>Nu tiene un nÃºmero pequeÃ±o, pero creciente, de variables internas que puedes establecer cambios en su aspecto y funcionamiento. A continuaciÃ³n una lista de las variables actuales, sus tipos, y una descripciÃ³n de cÃ³mo se utilizan:</p>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Tipo</th>\n<th>DescripciÃ³n</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>completion_mode</td>\n<td>&quot;list&quot; o &quot;circular&quot;</td>\n<td>el estilo de autocompletar a usar</td>\n</tr>\n<tr>\n<td>ctrlc_exit</td>\n<td>booleano</td>\n<td>salir o no de Nu despuÃ©s de presionar ctrl-c varias veces</td>\n</tr>\n<tr>\n<td>disable_table_indexes</td>\n<td>booleano</td>\n<td>elimina la columna de Ã­ndice de la tabla</td>\n</tr>\n<tr>\n<td>edit_mode</td>\n<td>&quot;vi&quot; o &quot;emacs&quot;</td>\n<td>cambia ediciÃ³n de lÃ­nea a modo &quot;vi&quot; o &quot;emacs&quot;</td>\n</tr>\n<tr>\n<td>env</td>\n<td>fila</td>\n<td>variables de entorno que serÃ¡n pasadas a comandos externos</td>\n</tr>\n<tr>\n<td>header_align</td>\n<td>&quot;center&quot;, &quot;right&quot;, u otro</td>\n<td>alinea los encabezados de la tabla alineados al centro, a la derecha o a la izquierda</td>\n</tr>\n<tr>\n<td>key_timeout</td>\n<td>entero</td>\n<td>el tiempo de espera utilizado para cambiar entre los modos de ediciÃ³n</td>\n</tr>\n<tr>\n<td>nonzero_exit_errors</td>\n<td>booleano</td>\n<td>si imprimir errores para cÃ³digos de salida no-ceros para externos</td>\n</tr>\n<tr>\n<td>path</td>\n<td>tabla de cadenas</td>\n<td>PATH para usar en bÃºsqueda de binarios</td>\n</tr>\n<tr>\n<td>startup</td>\n<td>lista de cadenas</td>\n<td>comandos, como <code>alias</code>es, para ejecutar cuando nushell arranca</td>\n</tr>\n<tr>\n<td>table_mode</td>\n<td>&quot;light&quot; o otro</td>\n<td>habilitar tablas livianas o normales</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"uso\" tabindex=\"-1\"> Uso</h2>\n<h3 id=\"configuracion-de-variables\" tabindex=\"-1\"> ConfiguraciÃ³n de variables</h3>\n<p>Para establecer una de estas variables, puedes usar <code>config set</code>. Por ejemplo:</p>\n<div><pre><code>> config set edit_mode \"vi\"\n</code></pre></div><h3 id=\"estableciendo-una-variable-desde-la-tuberia\" tabindex=\"-1\"> Estableciendo una variable desde la tuberÃ­a</h3>\n<p>Hay una manera adicional de establecer una variable, y es usar el contenido de la tuberÃ­a como el valor deseado para la variable. Para esto usa la bandera <code>set-into</code>:</p>\n<div><pre><code>> echo \"bar\" | config set_into foo\n</code></pre></div><p>Esto es de utilidad cuando se trabaja con las variables <code>env</code> y <code>path</code>.</p>\n<h3 id=\"listado-de-todas-las-variables\" tabindex=\"-1\"> Listado de todas las variables.</h3>\n<p>Ejecutando el comando <code>config</code> sin argumentos mostrarÃ¡ una tabla de las preferencias de configuraciÃ³n actuales:</p>\n<div><pre><code>> config\nâ”â”â”â”â”â”â”â”â”â”â”â”¯â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”¯â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”¯â”â”â”â”â”â”â”â”â”â”â”â”\n edit_mode â”‚ env            â”‚ path             â”‚ table_mode\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n emacs     â”‚ [table: 1 row] â”‚ [table: 10 rows] â”‚ normal\nâ”â”â”â”â”â”â”â”â”â”â”â”·â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”·â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”·â”â”â”â”â”â”â”â”â”â”â”â”\n</code></pre></div><p>Nota: si por el momento no has establecido variables de configuraciÃ³n, puede estar vacÃ­a.</p>\n<h3 id=\"obteniendo-una-variable\" tabindex=\"-1\"> Obteniendo una variable</h3>\n<p>Usando la bandera <code>get</code>, puedes conseguir el valor de una variable:</p>\n<div><pre><code>> config get edit_mode\n</code></pre></div><h3 id=\"eliminando-una-variable\" tabindex=\"-1\"> Eliminando una variable</h3>\n<p>Para eliminar una variable de la configuraciÃ³n, usa la bandera <code>remove</code>:</p>\n<div><pre><code>> config remove edit_mode\n</code></pre></div><h3 id=\"borrar-toda-la-configuracion\" tabindex=\"-1\"> Borrar toda la configuraciÃ³n</h3>\n<p>Si deseas borrar toda la configuraciÃ³n y empezar de cero, puedes usar la bandera <code>clear</code>. Por supuesto, tenga precauciÃ³n con esto ya que una vez ejecutado el archivo de configuraciÃ³n tambiÃ©n se eliminarÃ¡.</p>\n<div><pre><code>> config clear\n</code></pre></div><h3 id=\"encontrar-donde-se-almacena-el-archivo-de-configuracion\" tabindex=\"-1\"> Encontrar dÃ³nde se almacena el archivo de configuraciÃ³n</h3>\n<p>El archivo de configuraciÃ³n se carga desde una ubicaciÃ³n predeterminada. Para encontrar esta ubicaciÃ³n en el sistema, puedes solicitarla usando la bandera <code>path</code>:</p>\n<div><pre><code>config path\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n &lt;value>\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n /home/nusheller/.config/nu/config.toml\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n</code></pre></div><h3 id=\"cargando-la-configuracion-desde-un-archivo\" tabindex=\"-1\"> Cargando la configuraciÃ³n desde un archivo</h3>\n<p>Es posible que desees cargar la configuraciÃ³n desde una ubicaciÃ³n distinta a la predeterminada. Para hacerlo, usa la bandera <code>load</code>:</p>\n<div><pre><code>> config load myconfiguration.toml\n</code></pre></div><h2 id=\"configurando-nu-como-shell-de-inicio-de-sesion\" tabindex=\"-1\"> Configurando Nu como shell de inicio de sesiÃ³n</h2>\n<p>Para usar Nu como shell de inicio de sesiÃ³n, necesitarÃ¡s configurar las variables <code>path</code> y <code>env</code>. Con estos, obtendrÃ¡s suficiente soporte para ejecutar comandos externos como shell de inicio de sesiÃ³n.</p>\n<p>Antes de cambiarlo, ejecuta Nu dentro de otra shell, como Bash. Luego, obtÃ©n el entorno y PATH desde esa shell con los siguientes comandos:</p>\n<div><pre><code>> config set path $nu.path\n> config set env $nu.env\n</code></pre></div><p><code>$nu.path</code> y <code>$nu.env</code> son valores que estÃ¡n prestablecidas a las variables actuales de entorno y PATH, respectivamente. Una vez que las estableces a la configuraciÃ³n, estarÃ¡n disponibles cuando uses Nu como shell de inicio de sesiÃ³n.</p>\n<p>A continuaciÃ³n, en algunas distribuciones tambiÃ©n deberÃ¡s asegurarte de que Nu estÃ© en la lista en <code>/etc/shells</code>:</p>\n<div><pre><code>â¯ cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\n/usr/bin/screen\n/usr/bin/fish\n/home/jonathan/.cargo/bin/nu\n</code></pre></div><p>Con esto, deberÃ­as de poder hacer <code>chsh</code> y establecer Nu como la shell de inicio de sesiÃ³n. Luego de cerrar sesiÃ³n, en el prÃ³ximo inicio de sesiÃ³n deberÃ­as de recibir un brillante mensaje de Nu.</p>\n<h2 id=\"configuracion-del-prompt\" tabindex=\"-1\"> ConfiguraciÃ³n del prompt</h2>\n<p>Actualmente, la configuraciÃ³n del prompt es manejada instalando Nu con el soporte prompt proporcionado con <a href=\"https://github.com/starship/starship\" target=\"_blank\" rel=\"noopener noreferrer\">starship</a>.</p>\n<div><pre><code>nushell on ğŸ“™ master [$] is ğŸ“¦ v0.5.1 via ğŸ¦€ v1.40.0-nightly\nâ¯\n</code></pre></div><p>Starship es un prompt divertido, colorido y sorprendentemente poderoso. Para configurarlo, sigue los pasos en su <a href=\"https://starship.rs/config/\" target=\"_blank\" rel=\"noopener noreferrer\">manual de configuraciÃ³n</a>.</p>\n",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Entorno",
      "url": "www.nushell.sh/es/book/entorno.html",
      "id": "www.nushell.sh/es/book/entorno.html",
      "content_html": "<h1 id=\"entorno\" tabindex=\"-1\"> Entorno</h1>\n<p>Una tarea comÃºn al usar una shell es controlar el ambiente de entorno que aplicaciones externas usarÃ¡n. ComÃºnmente esto sucede automÃ¡ticamente, a medida que el entorno se empaqueta y se entrega a la aplicaciÃ³n externa cuando se inicia. Sin embargo, hay veces que vamos a desear tener control mÃ¡s preciso sobre quÃ© variables de entorno una aplicaciÃ³n pueda ver.</p>\n<p>Puedes ver las variables de entorno actuales que se enviarÃ¡n a las aplicaciones explorando <code>#nu.env</code>:</p>\n<div><pre><code>> echo $nu.env\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n COLORTERM                â”‚ truecolor\n DBUS_SESSION_BUS_ADDRESS â”‚ unix:path=/run/user/1000/bus\n DESKTOP_SESSION          â”‚ gnome\n DISPLAY                  â”‚ :1\n</code></pre></div><p>El ambiente es creador a travÃ©s de los ajustes en la configuraciÃ³n de Nu y a partir del entorno en el que se ejecuta Nu. Puedes actualizar el ambiente permanentement usando tÃ©cnicas enumeradas en el capÃ­tulo de <a href=\"/es/book/configuracion.html\">configuraciÃ³n</a>.</p>\n<p>TambiÃ©n puedes temporalmente actualizar una variable de entorno cuando ejecutas un comando o tuberÃ­a de comandos.</p>\n<div><pre><code>> with-env [MI_VARIABLE VALOR] { echo $nu.env.MI_VARIABLE }\nVALOR\n</code></pre></div><p>El comando <code>with-env</code> establecerÃ¡ temporalmente la variable de entorno dada (aquÃ­: la variable &quot;MI_VARIABLE&quot; es dada el valor &quot;VALOR&quot;). Una vez hecho esto, el bloque se ejecutarÃ¡ con esta nueva variable de entorno establecida.</p>\n<p>A common shorthand, inspired by Bash and others, is also available. You can write the above example as:</p>\n<p>Una atajo comÃºn, inspirada en Bash y otros, tambiÃ©n estÃ¡ disponible. Puedes escribir el ejemplo anterior como:</p>\n<div><pre><code>> MI_VARIABLE=VALOR echo $nu.env.MI_VARIABLE\nVALOR\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Escapando al sistema",
      "url": "www.nushell.sh/es/book/escapando.html",
      "id": "www.nushell.sh/es/book/escapando.html",
      "content_html": "<h1 id=\"escapando-al-sistema\" tabindex=\"-1\"> Escapando al sistema</h1>\n<p>Nu proporciona una serie de comandos que puedes utilitar en diferentes sistemas operativos y tener esta consistencia es de gran ayuda. Sin embargo, a veces, quieres ejecutar un comando que tambiÃ©n tiene el mismo nombre de los comandos de Nu. Para ejecutar el comando local <code>ls</code> o <code>date</code> fuera de Nu por ejemplo, usa el comando de intercalaciÃ³n (^).</p>\n<p>Comando de Nu:</p>\n<div><pre><code>> ls\n</code></pre></div><p>Escapa al comando local:</p>\n<div><pre><code>> ^ls\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Explorando en el sistema",
      "url": "www.nushell.sh/es/book/explorando.html",
      "id": "www.nushell.sh/es/book/explorando.html",
      "content_html": "<h1 id=\"explorando-en-el-sistema\" tabindex=\"-1\"> Explorando en el sistema</h1>\n<p>Shells de antes permiten explorar el sistema de archivos y ejecutar comandos. Shells modernas como Nu permiten hacer lo mismo. Miremos algunos comandos comunes que puedas usar cuando interactues con el sistema.</p>\n<h2 id=\"ver-contenido-de-un-directorio\" tabindex=\"-1\"> Ver contenido de un directorio</h2>\n<div><pre><code><span>></span> <span>ls</span>\n</code></pre></div><p>CÃ³mo hemos visto en otros capÃ­tulos, <code>ls</code> es un comando para mirar el contenido de una ruta. Nu devolverÃ¡ el contenido en una tabla que podemos usar.</p>\n<p>El comando <code>ls</code> tambiÃ©n recibe un argumento opcional para cambiar quÃ© te gustarÃ­a ver. Por ejemplo, podemos enumerar los archivos que terminan en &quot;.md&quot;</p>\n<div><pre><code><span>></span> <span>ls</span> *.md\nâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n <span># â”‚ name               â”‚ type â”‚ size    â”‚ modified </span>\nâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n <span>0</span> â”‚ CODE_OF_CONDUCT.md â”‚ File â”‚  <span>3.4</span> KB â”‚ <span>5</span> days ago \n <span>1</span> â”‚ CONTRIBUTING.md    â”‚ File â”‚   <span>886</span> B â”‚ <span>5</span> days ago \n <span>2</span> â”‚ README.md          â”‚ File â”‚ <span>15.0</span> KB â”‚ <span>5</span> days ago \n <span>3</span> â”‚ TODO.md            â”‚ File â”‚  <span>1.6</span> KB â”‚ <span>5</span> days ago \nâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n</code></pre></div><p>El asterisco (*) en el argumento que pasamos &quot;*.md&quot; a veces se llama comodÃ­n o glob. Nos permite complementar cualquier cosa. Puedes leer el glob &quot;*.md&quot; como &quot;complementa cualquier archivo siempre y cuando termine en '.md'&quot;</p>\n<p>Nu tambiÃ©n usa globs modernos permitiendo acceder directorios mÃ¡s profundos.</p>\n<div><pre><code> <span>ls</span> **/*.md\nâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n <span>#  â”‚ name                                      â”‚ type â”‚ size    â”‚ modified </span>\nâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  <span>0</span> â”‚ .github/ISSUE_TEMPLATE/bug_report.md      â”‚ File â”‚   <span>592</span> B â”‚ <span>5</span> days ago \n  <span>1</span> â”‚ .github/ISSUE_TEMPLATE/feature_request.md â”‚ File â”‚   <span>595</span> B â”‚ <span>5</span> days ago \n  <span>2</span> â”‚ CODE_OF_CONDUCT.md                        â”‚ File â”‚  <span>3.4</span> KB â”‚ <span>5</span> days ago \n  <span>3</span> â”‚ CONTRIBUTING.md                           â”‚ File â”‚   <span>886</span> B â”‚ <span>5</span> days ago \n  <span>4</span> â”‚ README.md                                 â”‚ File â”‚ <span>15.0</span> KB â”‚ <span>5</span> days ago \n  <span>5</span> â”‚ TODO.md                                   â”‚ File â”‚  <span>1.6</span> KB â”‚ <span>5</span> days ago \n  <span>6</span> â”‚ crates/nu-source/README.md                â”‚ File â”‚  <span>1.7</span> KB â”‚ <span>5</span> days ago \n  <span>7</span> â”‚ docker/packaging/README.md                â”‚ File â”‚  <span>1.5</span> KB â”‚ <span>5</span> days ago \n  <span>8</span> â”‚ docs/commands/README.md                   â”‚ File â”‚   <span>929</span> B â”‚ <span>5</span> days ago \n  <span>9</span> â”‚ docs/commands/alias.md                    â”‚ File â”‚  <span>1.7</span> KB â”‚ <span>5</span> days ago \n <span>10</span> â”‚ docs/commands/append.md                   â”‚ File â”‚  <span>1.4</span> KB â”‚ <span>5</span> days ago\n</code></pre></div><p>AquÃ­, buscamos cualquier archivo que termine con &quot;.md&quot;, y los dos asteriscos dicen ademÃ¡s &quot;en cualquier directorio que comience desde aquÃ­&quot;.</p>\n<h2 id=\"cambiar-el-directorio-actual\" tabindex=\"-1\"> Cambiar el directorio actual</h2>\n<div><pre><code><span>></span> <span>cd</span> new_directory\n</code></pre></div><p>Para cambiar del directorio actual a uno nuevo usamos el comando <code>cd</code>. Al igual que en otras shells, podemos usar tanto el nombre del directorio o si deseamos subir a un directorio podemos usar el acceso directo <code>..</code>.</p>\n<p>TambiÃ©n se puede cambiar el directorio si se omite <code>cd</code> y se proporciona una ruta por si sola:</p>\n<div><pre><code><span>></span> ./new_directory\n</code></pre></div><h2 id=\"comandos-del-sistema-de-archivos\" tabindex=\"-1\"> Comandos del sistema de archivos</h2>\n<p>Nu tambiÃ©n proporciona algunos comandos bÃ¡sicos del sistema de archivos que funcionan multiplataforma.</p>\n<p>Podemos mover un item de un lugar a otro usando el comando <code>mv</code>:</p>\n<div><pre><code><span>></span> <span>mv</span> item location\n</code></pre></div><p>Podemos copiar un item de un lugar a otro:</p>\n<div><pre><code><span>></span> <span>cp</span> item location\n</code></pre></div><p>Podemos eliminar un item.</p>\n<div><pre><code><span>></span> <span>rm</span> item\n</code></pre></div><p>Los tres comandos tambiÃ©n pueden usar las capacidades de glob que vimos previamente con <code>ls</code>.</p>\n<p>Finalmente, podemos crear un directorio usando el comando <code>mkdir</code>:</p>\n<div><pre><code><span>></span> <span>mkdir</span> new_directory\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.690Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Instalando Nu",
      "url": "www.nushell.sh/es/book/instalacion.html",
      "id": "www.nushell.sh/es/book/instalacion.html",
      "content_html": "<h1 id=\"instalando-nu\" tabindex=\"-1\"> Instalando Nu</h1>\n<p>La mejor manera actualmente para poner en marcha Nu es instalÃ¡ndolo a travÃ©s de <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a>, descargando desde <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">nuestra pÃ¡gina</a>, y compilar desde la fuente.</p>\n<h2 id=\"binarios\" tabindex=\"-1\"> Binarios</h2>\n<p>Puedes descargar Nu compilado desde <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">nuestra pÃ¡gina</a>. Alternativamente, si usas <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Homebrew</a> para macOS, puedes instalar el binario ejecutando <code>brew install nushell</code>.</p>\n<h3 id=\"windows\" tabindex=\"-1\"> Windows</h3>\n<p><strong>nota:</strong> Nu trabaja con Windows 10 y no soporta Windows 7/8.1</p>\n<p>Descarga el archivo actual <code>.zip</code> <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">de la pÃ¡gina de releases</a> y extrÃ¡elo por ejemplo a:</p>\n<div><pre><code> C:\\Program Files\n</code></pre></div><p>y posteriormente agrega Nu a la variable de entorno <code>PATH</code>. Una vez que hagamos eso, podemos ejecutar Nu usando el comando <code>nu</code>:</p>\n<div><pre><code> > nu\n C:\\Users\\user>\n</code></pre></div><p>Si te encuentras usando <a href=\"https://github.com/microsoft/terminal\" target=\"_blank\" rel=\"noopener noreferrer\">Windows Terminal</a> puedes establecer <code>nu</code> como la shell por defecto aÃ±adiendo:</p>\n<div><pre><code>{\n \"guid\": \"{2b372ca1-1ee2-403d-a839-6d63077ad871}\",\n \"hidden\": false,\n \"name\": \"Nu Shell\",\n \"commandline\": \"nu.exe\"\n}\n</code></pre></div><p>a <code>&quot;profiles&quot;</code> en las preferencias de tu Terminal (archivo JSON). Lo Ãºltimo que tienes que hacer es cambiar <code>&quot;defaultProfile&quot;</code> a:</p>\n<div><pre><code>\"defaultProfile\": \"{2b372ca1-1ee2-403d-a839-6d63077ad871}\",\n</code></pre></div><p>Ahora <code>nu</code> deberÃ­a cargar al inicio de la Terminal de Windows.</p>\n<h2 id=\"preparacion\" tabindex=\"-1\"> PreparaciÃ³n</h2>\n<p>Antes de que podamos instalar Nu, necesitamos asegurarnos de que nuestro sistema tenga los requerimientos necesarios. Actualmente significa que debemos verificar tener instalado tanto el Rust toolchain asÃ­ como las dependencias locales. EstÃ¡s son las suites de compilaciÃ³n recomendadas:</p>\n<ul>\n<li>Linux: GCC or Clang</li>\n<li>macOS: Clang (install Xcode)</li>\n<li>Windows: <a href=\"https://visualstudio.microsoft.com/vs/community/\" target=\"_blank\" rel=\"noopener noreferrer\">Visual Studio Community Edition</a></li>\n</ul>\n<p>Para Linux y macOS, una vez que hayas instalado la suite de compilaciÃ³n, todo estarÃ¡ listo para instalar Rust a travÃ©s de <code>rustup</code> (ver mÃ¡s abajo).</p>\n<p>For Windows, when you install Visual Studio Community Edition, make sure to install the &quot;C++ build tools&quot; as what we need is <code>link.exe</code> which is provided as part of that optional install. With that, we're ready to move to the next step.</p>\n<p>Para Windows, cuando instalas Visual Studio Community Edition, asegÃºrate de instalar las herramientas &quot;C++ build tools&quot; ya que lo que necesitamos es <code>link.exe</code>, que es proporcionado como parte de esa instalaciÃ³n optcional. Con eso, estamos listos para el siguiente paso.</p>\n<h3 id=\"instalando-un-suite-de-compilacion\" tabindex=\"-1\"> Instalando un suite de compilaciÃ³n</h3>\n<p>Para que Rust funcione correctamente, necesitarÃ¡s tener un suite de compilaciÃ³n compatible instalado en el sistema.</p>\n<h3 id=\"instalando-rust\" tabindex=\"-1\"> Instalando Rust</h3>\n<p>En el caso de que no dispongamos de Rust en nuestro sistema la mejor manera de instalarlo es mediante <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">rustup</a>. Rustup es una manera de manejar instalaciones de Rust incluyendo distintas versiones de Rust.</p>\n<p>Nu actualmente requiere la versiÃ³n <strong>estable mÃ¡s reciente (1.55 o posterior)</strong> de Rust. La mejor manera de <code>rustup</code> inferir la versiÃ³n correcta para ti. En el momento de abrir <code>rustup</code> te solicitarÃ¡ quÃ© versiÃ³n de Rust deseas instalar:</p>\n<div><pre><code>Current installation options:\n\n   default host triple: x86_64-unknown-linux-gnu\n     default toolchain: stable\n  modify PATH variable: yes\n\n1) Proceed with installation (default)\n2) Customize installation\n3) Cancel installation\n</code></pre></div><p>Una vez que estamos listos, presionamos 1 y luego enter.</p>\n<p>Si prefieres no instalar Rust mediante <code>rustup</code>, tambiÃ©n puedes instalar a travÃ©s de otros mÃ©todos (Ej. un paquete en alguna distribuciÃ³n de Linux). Solo asegÃºrate de instalar una versiÃ³n que sea Rust 1.55 o posterior.</p>\n<h2 id=\"dependencias\" tabindex=\"-1\"> Dependencias</h2>\n<h3 id=\"debian-ubuntu\" tabindex=\"-1\"> Debian/Ubuntu</h3>\n<p>Vas a necesitar instalar &quot;pkg-config&quot; y &quot;libssl-dev&quot;:</p>\n<p>&lt;&lt;&lt; @/snippets/installation/install_pkg_config_libssl_dev.sh</p>\n<p>Usuarios de Linux que desean usar las funcionalidades opcionales <code>rawkey</code> o <code>clipboard</code> necesitarÃ¡n instalar los paquetes &quot;libx11-dev&quot; y &quot;libxcb-composite0-dev&quot;:</p>\n<p>&lt;&lt;&lt; @/snippets/installation/use_rawkey_and_clipboard.sh</p>\n<h3 id=\"distribuciones-basadas-en-rhel\" tabindex=\"-1\"> Distribuciones basadas en RHEL</h3>\n<p>Vas a necesitar instalar &quot;libxcb&quot;, &quot;openssl-devel&quot; and &quot;libX11-devel&quot;:</p>\n<p>&lt;&lt;&lt; @/snippets/installation/install_rhel_dependencies.sh</p>\n<h3 id=\"macos\" tabindex=\"-1\"> macOS</h3>\n<p>Usando <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">homebrew</a>, vas a necesitar instalar la fÃ³rmula &quot;openssl&quot;:</p>\n<div><pre><code>brew install openssl cmake\n</code></pre></div><h2 id=\"instalando-desde-crates-io\" tabindex=\"-1\"> Instalando desde <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a></h2>\n<p>Una vez instaladas las depependencias que Nu necesita, podemos instalarla usando el comando <code>cargo</code> que viene con el compilador Rust.</p>\n<div><pre><code>> cargo install nu\n</code></pre></div><p>Â¡Eso es todo! Cargo harÃ¡ el trabajo de descarga Nu junto con sus dependencias, construirla e instalarla en el bin path de cargo para que podamos arrancarlo.</p>\n<p>Si deseas instalar con mÃ¡s funcionalidades, puedes hacer:</p>\n<div><pre><code>> cargo install nu --features=stable\n</code></pre></div><p>Para todas las funcionalidades disponibles, la manera mÃ¡s fÃ¡cil es descargar la fuente de Nu y construÃ­rlo usted mismo usando las herramientas de Rust:</p>\n<div><pre><code>> git clone https://github.com/nushell/nushell.git\n> cd nushell\nnushell> cargo install --path . --force --features=stable\n\nPara que esto funcione, asegÃºrate de tener todas las dependencias instaladas (que se muestran arriba) en el sistema.\n\nFinalizada la instalaciÃ³n podemos ejecutar Nu usando el comando `nu`:\n\n</code></pre></div><p>$ nu\n/home/jonathan/Source&gt;</p>\n<div><pre><code>\n## Construyendo desde la fuente\n\nTambiÃ©n podemos contruir nuestro propio Nu directamente desde github. Esto nos da acceso inmediato a las Ãºltimas funcionalidades y correcciÃ³n de bugs.\n\n</code></pre></div><blockquote>\n<p>git clone https://github.com/nushell/nushell.git</p>\n</blockquote>\n<div><pre><code>\nGit nos clonarÃ¡ el repositorio principal de Nu. Partiendo de ahÃ­ podemos contruir y arrancar Nu si estamos usando `rustup` con:\n\n</code></pre></div><blockquote>\n<p>cd nushell\nnushell&gt; cargo build --workspace --features=stable &amp;&amp; cargo run --features=stable</p>\n</blockquote>\n<div><pre><code>\nTambiÃ©n puedes construir y arrancar Nu en modo release:\n\n</code></pre></div><p>nushell&gt; cargo build --release --workspace --features=stable &amp;&amp; cargo run --release --features=stable</p>\n<div><pre><code>Gente familiarizada con Rust se preguntarÃ¡ la razÃ³n por la que hacemos un paso \"build\" y otro paso \"run\" si \"run\" construye por defecto. Esto es para evitar una deficiencia de la nueva opciÃ³n `default-run` en Cargo y asegurar que todos los plugins se construyan aunque puede que esto no sea necesario en el futuro.\n\n**Nota:** Si te encuentras trabajando tanto en modo debug y release, asegÃºrate de ejecutar `cargo clean` cuando cambies entre ellas. Nu buscarÃ¡ plugins en los directorios tanto de debug asÃ­ como release y puede suceder que cargue versiones de un plugin que no tienes intenciones de usar.\n\n## Establecer como shell de inicio de sesiÃ³n\n\n**!!! Nu todavÃ­a estÃ¡ en desarrollo y puede no ser estable para uso diario. !!!**\n\nPara configurar la shell de inicio de sesiÃ³n, puedes usra el comando [`chsh`](https://linux.die.net/man/1/chsh).\nEn algunas distribuciones de Linux se encuentra una lista vÃ¡lida de shells en `/etc/shells` y no permitirÃ¡ cambiar la shell hasta que Nu estÃ© en la lista blanca. Es posible que vea un error similar al siguiente si no ha actualizado el archivo `shells`:\n\n</code></pre></div><p>chsh: /home/username/.cargo/bin/nu is an invalid shell</p>\n<div><pre><code>\nPuedes agregar Nu a la lista de shells vÃ¡lidas aÃ±adiendo el binario al archivo `shells`. La ruta para agregar puedes encontrarla con el comando `which nu`, usualmente es `$HOME/.cargo/bin/nu`.\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.690Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Llegando desde Bash",
      "url": "www.nushell.sh/es/book/llegando_de_bash.html",
      "id": "www.nushell.sh/es/book/llegando_de_bash.html",
      "content_html": "<h1 id=\"llegando-desde-bash\" tabindex=\"-1\"> Llegando desde Bash</h1>\n<p>Nota: Esta tabla asume Nushell 0.14.1 or posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Bash</th>\n<th>Nu</th>\n<th>Task</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ls</code></td>\n<td><code>ls</code></td>\n<td>Lists the files in the current directory</td>\n</tr>\n<tr>\n<td><code>ls &lt;dir&gt;</code></td>\n<td><code>ls &lt;dir&gt;</code></td>\n<td>Lists the files in the given directory</td>\n</tr>\n<tr>\n<td><code>ls pattern*</code></td>\n<td><code>ls pattern*</code></td>\n<td>Lists files that match a given pattern</td>\n</tr>\n<tr>\n<td><code>ls -la</code></td>\n<td><code>ls --long --all</code> or <code>ls -la</code></td>\n<td>List files with all available information, including hidden files</td>\n</tr>\n<tr>\n<td><code>ls -d */</code></td>\n<td><code>ls | where type == Dir</code></td>\n<td>List directories</td>\n</tr>\n<tr>\n<td><code>find . -name *.rs</code></td>\n<td><code>ls **/*.rs</code></td>\n<td>Find recursively all files that match a given pattern</td>\n</tr>\n<tr>\n<td><code>cd &lt;directory&gt;</code></td>\n<td><code>cd &lt;directory&gt;</code></td>\n<td>Change to the given directory</td>\n</tr>\n<tr>\n<td><code>cd</code></td>\n<td><code>cd</code></td>\n<td>Change to the home directory</td>\n</tr>\n<tr>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td>Creates the given path</td>\n</tr>\n<tr>\n<td><code>mkdir -p &lt;path&gt;</code></td>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td>Creates the given path, creating parents as necessary</td>\n</tr>\n<tr>\n<td><code>touch test.txt</code></td>\n<td><code>touch test.txt</code></td>\n<td>Create a file</td>\n</tr>\n<tr>\n<td><code>&gt; &lt;path&gt;</code></td>\n<td><code>| save --raw &lt;path&gt;</code></td>\n<td>Save string into a file</td>\n</tr>\n<tr>\n<td><code>cat &lt;path&gt;</code></td>\n<td><code>open --raw &lt;path&gt;</code></td>\n<td>Display the contents of the given file</td>\n</tr>\n<tr>\n<td></td>\n<td><code>open &lt;path&gt;</code></td>\n<td>Read a file as structured data</td>\n</tr>\n<tr>\n<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Move file to new location</td>\n</tr>\n<tr>\n<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Copy file to new location</td>\n</tr>\n<tr>\n<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Copy directory to a new location, recursively</td>\n</tr>\n<tr>\n<td><code>rm &lt;path&gt;</code></td>\n<td><code>rm &lt;path&gt;</code></td>\n<td>Remove the given file</td>\n</tr>\n<tr>\n<td></td>\n<td><code>rm -t &lt;path&gt;</code></td>\n<td>Move the given file to the system trash</td>\n</tr>\n<tr>\n<td><code>rm -rf &lt;path&gt;</code></td>\n<td><code>rm -r &lt;path&gt;</code></td>\n<td>Recursively removes the given path</td>\n</tr>\n<tr>\n<td><code>chmod</code></td>\n<td><code>&lt;not yet possible&gt;</code></td>\n<td>Changes the file attributes</td>\n</tr>\n<tr>\n<td><code>date -d &lt;date&gt;</code></td>\n<td><code>echo &lt;date&gt; | str to-datetime -f &lt;format&gt;</code></td>\n<td>Parse a date (<a href=\"https://docs.rs/chrono/0.4.15/chrono/format/strftime/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">format documentation</a>)</td>\n</tr>\n<tr>\n<td><code>sed</code></td>\n<td><code>str find-replace</code></td>\n<td>Find and replace a pattern in a string</td>\n</tr>\n<tr>\n<td><code>grep &lt;pattern&gt;</code></td>\n<td><code>where $it =~ &lt;substring&gt;</code></td>\n<td>Filter strings that contain the substring</td>\n</tr>\n<tr>\n<td><code>man &lt;command&gt;</code></td>\n<td><code>help &lt;command&gt;</code></td>\n<td>Get the help for a given command</td>\n</tr>\n<tr>\n<td></td>\n<td><code>help commands</code></td>\n<td>List all available commands</td>\n</tr>\n<tr>\n<td></td>\n<td><code>help --find &lt;string&gt;</code></td>\n<td>Search for match in all available commands</td>\n</tr>\n<tr>\n<td><code>command1 &amp;&amp; command2</code></td>\n<td><code>command1; command2</code></td>\n<td>Run a command, and if it's successful run a second</td>\n</tr>\n<tr>\n<td><code>stat $(which git)</code></td>\n<td><code>stat (which git).path</code></td>\n<td>Use command output as argument for other command</td>\n</tr>\n<tr>\n<td><code>echo $PATH</code></td>\n<td><code>echo $nu.path</code></td>\n<td>See the current path</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>config set path [&lt;dir1&gt; &lt;dir2&gt; ...]</code></td>\n<td>Update PATH permanently</td>\n</tr>\n<tr>\n<td><code>export PATH = $PATH:/usr/other/bin</code></td>\n<td><code>pathvar add &lt;path&gt;</code></td>\n<td>Update PATH temporarily</td>\n</tr>\n<tr>\n<td><code>export</code></td>\n<td><code>echo $nu.env</code></td>\n<td>List the current environment variables</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>echo $nu.env | insert var value | config set_into env</code></td>\n<td>Update environment variables permanently</td>\n</tr>\n<tr>\n<td><code>FOO=BAR ./bin</code></td>\n<td><code>FOO=BAR ./bin</code></td>\n<td>Update environment temporarily</td>\n</tr>\n<tr>\n<td><code>export FOO=BAR</code></td>\n<td><code>let-env FOO = BAR</code></td>\n<td>Set environment variable for current session</td>\n</tr>\n<tr>\n<td><code>unset FOO</code></td>\n<td><code>let-env FOO = $nothing</code></td>\n<td>Unset environment variable for current session</td>\n</tr>\n<tr>\n<td><code>alias s=&quot;git status -sb&quot;</code></td>\n<td><code>alias s = git status -sb</code></td>\n<td>Define an alias temporarily</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>config set [startup [&quot;alias myecho [msg] { echo Hello $msg }&quot;]]</code></td>\n<td>Add a first alias permanently (for new shells)</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>config get startup | append &quot;alias s [] { git status -sb }&quot; | config set_into startup</code></td>\n<td>Add an additional alias permanently (for new shells)</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>&lt;update nu/config.toml&gt;</code></td>\n<td>Add and edit alias permanently (for new shells), find path for the file with <code>config path</code></td>\n</tr>\n<tr>\n<td><code>bash -c &lt;commands&gt;</code></td>\n<td><code>nu -c &lt;commands&gt;</code></td>\n<td>Run a pipeline of commands (requires 0.9.1 or later)</td>\n</tr>\n<tr>\n<td><code>bash &lt;script file&gt;</code></td>\n<td><code>nu &lt;script file&gt;</code></td>\n<td>Run a script file (requires 0.9.1 or later)</td>\n</tr>\n<tr>\n<td><code>\\</code></td>\n<td><code>&lt;not yet possible&gt;</code></td>\n<td>Line continuation is not yet supported.</td>\n</tr>\n</tbody>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.690Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa nushell de lenguajes funcionales",
      "url": "www.nushell.sh/es/book/mapa_funcional_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_funcional_nushell.html",
      "content_html": "<h1 id=\"mapa-nushell-de-lenguajes-funcionales\" tabindex=\"-1\"> Mapa nushell de lenguajes funcionales</h1>\n<p>La idea detrÃ¡s de esta tabla is ayudarte a entender como los comandos internos y plugins en Nu se relacionan con lenguajes funcionales. Hemos intentado producir un mapa de los comandos internos y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: Esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>Clojure</th>\n<th>Tablecloth (Ocaml / Elm)</th>\n<th>Haskell</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alias</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>append</td>\n<td>conj</td>\n<td></td>\n<td>(++)</td>\n<td></td>\n</tr>\n<tr>\n<td>args</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoview</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>average(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>binaryview(<code>*</code>)</td>\n<td>Integer/toHexString</td>\n<td></td>\n<td>showHex</td>\n<td></td>\n</tr>\n<tr>\n<td>calc, = math</td>\n<td>math operators</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>cd</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clear</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clip</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>compact</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>config</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td>count</td>\n<td>length</td>\n<td>length</td>\n<td></td>\n</tr>\n<tr>\n<td>cp</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>java.time.LocalDate/now</td>\n<td></td>\n<td>Get-Date</td>\n<td></td>\n</tr>\n<tr>\n<td>debug</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>drop</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>du</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>each</td>\n<td>map</td>\n<td>map</td>\n<td>map</td>\n<td></td>\n</tr>\n<tr>\n<td>echo</td>\n<td>println</td>\n<td></td>\n<td>putStrLn, print</td>\n<td></td>\n</tr>\n<tr>\n<td>enter</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>evaluate_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>exit</td>\n<td>System/exit</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>fetch(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>first</td>\n<td>first</td>\n<td></td>\n<td>head</td>\n<td></td>\n</tr>\n<tr>\n<td>format</td>\n<td>format</td>\n<td></td>\n<td>Text.Printf.printf</td>\n<td></td>\n</tr>\n<tr>\n<td>from bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from csv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from eml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ics</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ini</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from json</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ods</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from sqlite</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ssv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from vcf</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xlsx</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>get</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>group_by</td>\n<td>group-by</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>headers</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>help</td>\n<td>doc</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>histogram</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>history</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>inc(<code>*</code>)</td>\n<td>inc</td>\n<td></td>\n<td>succ</td>\n<td></td>\n</tr>\n<tr>\n<td>insert</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>is_empty</td>\n<td>empty?</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep</td>\n<td>take, drop-last, pop</td>\n<td></td>\n<td>init, take</td>\n<td></td>\n</tr>\n<tr>\n<td>keep_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_while</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kill</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>last</td>\n<td>last, peek</td>\n<td></td>\n<td>last</td>\n<td></td>\n</tr>\n<tr>\n<td>lines</td>\n<td></td>\n<td></td>\n<td>lines, words, split-with</td>\n<td></td>\n</tr>\n<tr>\n<td>ls</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>map_max_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>match(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>merge</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>next</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>nth</td>\n<td>nth</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>open</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>parse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pivot</td>\n<td>(apply mapv vector matrix)</td>\n<td></td>\n<td>transpose</td>\n<td></td>\n</tr>\n<tr>\n<td>post(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prepend</td>\n<td>cons</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prev</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ps(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pwd</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>range</td>\n<td></td>\n<td></td>\n<td>1..10, 'a'..'f'</td>\n<td></td>\n</tr>\n<tr>\n<td>reduce_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reject</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rm</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>save</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>select(<code>***</code>)</td>\n<td>select-keys</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shells</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td>shuffle</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td>count</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip</td>\n<td>rest</td>\n<td></td>\n<td>tail</td>\n<td></td>\n</tr>\n<tr>\n<td>skip_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_while</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sort-by</td>\n<td>sort-by</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_column</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_row</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>str(<code>*</code>)</td>\n<td>clojure.string functions</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sum</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sys(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>table</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tags</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>textview(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tree(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to csv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to html</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to json</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to md</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to sqlite</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>touch</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>trim</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>uniq</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>update(<code>**</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>version</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>with_env</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>what</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>where</td>\n<td>filter</td>\n<td></td>\n<td>filter</td>\n<td></td>\n</tr>\n<tr>\n<td>which</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>wrap</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>*</code> - Pertenecen de los plugins standard</li>\n<li><code>**</code> - renombrada de <code>edit</code> a <code>update</code> en 0.13.1</li>\n<li><code>***</code> - renombrada de <code>pick</code> a <code>select</code> en 0.13.1</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.691Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa nushell de lenguajes imperativos",
      "url": "www.nushell.sh/es/book/mapa_imperativo_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_imperativo_nushell.html",
      "content_html": "<h1 id=\"mapa-nushell-de-lenguajes-imperativos\" tabindex=\"-1\"> Mapa nushell de lenguajes imperativos</h1>\n<p>La idea detrÃ¡s de esta tabla is ayudarte a entender como los comandos internos y plugins en Nu se relacionan con lenguajes imperativos. Hemos intentado producir un mapa de los comandos internos y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>Python</th>\n<th>Kotlin (Java)</th>\n<th>C++</th>\n<th>Rust</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alias</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>append</td>\n<td>list.append, set.add</td>\n<td>add</td>\n<td>push_back, emplace_back</td>\n<td>push, push_back</td>\n</tr>\n<tr>\n<td>args</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoview</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>average(<code>*</code>)</td>\n<td>statistics.mean</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>binaryview(<code>*</code>)</td>\n<td>&quot;{:x}&quot;.format</td>\n<td>Integer.toHexString</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>calc, = math</td>\n<td>math operators</td>\n<td>math operators</td>\n<td>math operators</td>\n<td>math operators</td>\n</tr>\n<tr>\n<td>cd</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clear</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clip</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>compact</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>config</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td>len</td>\n<td>size, length</td>\n<td>length</td>\n<td>len</td>\n</tr>\n<tr>\n<td>cp</td>\n<td>shutil.copy</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>datetime.date.today</td>\n<td>java.time.LocalDate.now</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>debug</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>drop</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>du</td>\n<td>shutil.disk_usage</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>each</td>\n<td>for</td>\n<td>for</td>\n<td>for</td>\n<td>for</td>\n</tr>\n<tr>\n<td>echo</td>\n<td>print</td>\n<td>println</td>\n<td>printf</td>\n<td>println!</td>\n</tr>\n<tr>\n<td>enter</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>evaluate_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>exit</td>\n<td>exit</td>\n<td>System.exit, kotlin.system.exitProcess</td>\n<td>exit</td>\n<td>exit</td>\n</tr>\n<tr>\n<td>fetch(<code>*</code>)</td>\n<td>urllib.request.urlopen</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>first</td>\n<td>list[0]</td>\n<td>List[0], peek</td>\n<td>vector[0], top</td>\n<td>vec[0]</td>\n</tr>\n<tr>\n<td>format</td>\n<td>format</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from csv</td>\n<td>csv</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from eml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ics</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ini</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from json</td>\n<td>json</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ods</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from sqlite</td>\n<td>sqlite3</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ssv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from vcf</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xlsx</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>get</td>\n<td>dict[&quot;key&quot;]</td>\n<td>Map[&quot;key&quot;]</td>\n<td>map[&quot;key&quot;]</td>\n<td></td>\n</tr>\n<tr>\n<td>group_by</td>\n<td>itertools.groupby</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>headers</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>help</td>\n<td>help</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>histogram</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>history</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>inc(<code>*</code>)</td>\n<td>x += 1</td>\n<td>x++</td>\n<td>x++</td>\n<td>+= 1</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>list.insert</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>is_empty</td>\n<td>is None</td>\n<td>isEmpty</td>\n<td>empty</td>\n<td></td>\n</tr>\n<tr>\n<td>keep</td>\n<td>list[:x]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_while</td>\n<td>itertools.takewhile</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>os.kill</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>last</td>\n<td>list[-1]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>lines</td>\n<td>split, splitlines</td>\n<td>split</td>\n<td>views::split</td>\n<td></td>\n</tr>\n<tr>\n<td>ls</td>\n<td>os.listdir</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>map_max_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>match(<code>*</code>)</td>\n<td>re</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>merge</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>os.mkdir</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mv</td>\n<td>shutil.move</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>next</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>nth</td>\n<td>list[x]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>open</td>\n<td>open</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>parse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pivot</td>\n<td>zip(*matrix)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>post(<code>*</code>)</td>\n<td>urllib.request.urlopen</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prepend</td>\n<td>deque.appendleft</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prev</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ps(<code>*</code>)</td>\n<td>os.listdir('/proc')</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>os.getcwd</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>range</td>\n<td>range</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reduce_by</td>\n<td>functools.reduce</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reject</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>shutil.move</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>reversed, list.reverse</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rm</td>\n<td>os.remove</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>save</td>\n<td>io.TextIOWrapper.write</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>select(<code>***</code>)</td>\n<td>{k:dict[k] for k in keylist}</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shells</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td>random.shuffle</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td>len</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip</td>\n<td>list[x:]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_while</td>\n<td>itertools.dropwhile</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sort-by</td>\n<td>sorted, list.sort</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_by</td>\n<td>re.split</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_column</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_row</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>str(<code>*</code>)</td>\n<td>str functions</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sum</td>\n<td>sum</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sys(<code>*</code>)</td>\n<td>sys</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>table</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tags</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>textview(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tree(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to csv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to html</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to json</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to md</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to sqlite</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>touch</td>\n<td>open(path, 'a').close()</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>trim</td>\n<td>strip, rstrip, lstrip</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>uniq</td>\n<td>set</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>update(<code>**</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>version</td>\n<td>sys.version, sys.version_info</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>with_env</td>\n<td>os.environ</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>what</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>where</td>\n<td>filter</td>\n<td>filter</td>\n<td>filter</td>\n<td>filter</td>\n</tr>\n<tr>\n<td>which</td>\n<td>shutil.which</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>wrap</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>*</code> - Pertenecen de los plugins standard</li>\n<li><code>**</code> - renombrada de <code>edit</code> a <code>update</code> en 0.13.1</li>\n<li><code>***</code> - renombrada de <code>pick</code> a <code>select</code> en 0.13.1</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.691Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa nushell de otras shells y lenguajes DSLs",
      "url": "www.nushell.sh/es/book/mapa_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_nushell.html",
      "content_html": "<h1 id=\"mapa-nushell-de-otras-shells-y-lenguajes-dsls\" tabindex=\"-1\"> Mapa nushell de otras shells y lenguajes DSLs</h1>\n<p>La idea detrÃ¡s de esta tabla is ayudarte a entender como los comandos internos y plugins en Nu se relacionan con otras shells conocidas y lenguajes de dominio especÃ­ficos. Hemos intentado producir un mapa de los comandos internos y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: Esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>SQL</th>\n<th>.Net LINQ (C#)</th>\n<th>PowerShell (without external modules)</th>\n<th>Bash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alias</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>alias</td>\n<td>alias</td>\n</tr>\n<tr>\n<td>append</td>\n<td>N/A</td>\n<td>Append()</td>\n<td>-Append</td>\n<td></td>\n</tr>\n<tr>\n<td>args</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoview</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>average(<code>*</code>)</td>\n<td>avg</td>\n<td>Average()</td>\n<td>Measure-Object, measure</td>\n<td></td>\n</tr>\n<tr>\n<td>binaryview(<code>*</code>)</td>\n<td>N/A</td>\n<td></td>\n<td>Format-Hex</td>\n<td></td>\n</tr>\n<tr>\n<td>calc, = math</td>\n<td>math operators</td>\n<td>Aggregate, Average, Count, Max, Min, Sum</td>\n<td></td>\n<td>bc</td>\n</tr>\n<tr>\n<td>cd</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Set-Location, cd</td>\n<td>cd</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Clear-Host</td>\n<td>clear</td>\n</tr>\n<tr>\n<td>clip</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Set-Clipboard, scb</td>\n<td>clip, clipboard, xclip, pbcopy</td>\n</tr>\n<tr>\n<td>compact</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>config</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>$Profile</td>\n<td>vi .bashrc, .profile</td>\n</tr>\n<tr>\n<td>count</td>\n<td>count</td>\n<td>Count</td>\n<td>Measure-Object, measure</td>\n<td>wc</td>\n</tr>\n<tr>\n<td>cp</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Copy-Item, cp, copy</td>\n<td>cp</td>\n</tr>\n<tr>\n<td>date</td>\n<td>NOW() / getdate()</td>\n<td>DateTime class</td>\n<td>Get-Date</td>\n<td>date</td>\n</tr>\n<tr>\n<td>debug</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>= dec</td>\n<td></td>\n<td>x--</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>drop</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>du</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td>du</td>\n</tr>\n<tr>\n<td>each</td>\n<td>cursor</td>\n<td></td>\n<td>ForEach-Object, foreach, for</td>\n<td></td>\n</tr>\n<tr>\n<td>echo</td>\n<td>print</td>\n<td>N/A</td>\n<td>Write-Output, write</td>\n<td>echo</td>\n</tr>\n<tr>\n<td>enter</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>evaluate_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>exit</td>\n<td>N/A</td>\n<td></td>\n<td>exit</td>\n<td>exit</td>\n</tr>\n<tr>\n<td>fetch(<code>*</code>)</td>\n<td>N/A</td>\n<td>HttpClient,WebClient, HttpWebRequest/Response</td>\n<td>Invoke-WebRequest</td>\n<td>wget</td>\n</tr>\n<tr>\n<td>first</td>\n<td>top, limit</td>\n<td>First, FirstOrDefault</td>\n<td>Select-Object -First</td>\n<td>head</td>\n</tr>\n<tr>\n<td>format</td>\n<td></td>\n<td>String.Format()</td>\n<td>String.Format()</td>\n<td></td>\n</tr>\n<tr>\n<td>from bson</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from csv</td>\n<td>import flatfile</td>\n<td>N/A</td>\n<td>Import-Csv, ConvertFrom-Csv</td>\n<td></td>\n</tr>\n<tr>\n<td>from eml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from ics</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from ini</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from json</td>\n<td>openjson</td>\n<td>N/A</td>\n<td>ConvertFrom-Json</td>\n<td></td>\n</tr>\n<tr>\n<td>from ods</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from sqlite</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from ssv</td>\n<td>import flatfile</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from toml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from tsv</td>\n<td>import flatfile</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from url</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from vcf</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from xlsx</td>\n<td>import</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from xml</td>\n<td>cast(variable as xml)</td>\n<td>N/A</td>\n<td>ConvertFrom-Xml</td>\n<td></td>\n</tr>\n<tr>\n<td>from yaml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>get</td>\n<td></td>\n<td>Select</td>\n<td>(cmd).column</td>\n<td></td>\n</tr>\n<tr>\n<td>group_by</td>\n<td>group by</td>\n<td>GroupBy, group</td>\n<td>Group-Object, group</td>\n<td></td>\n</tr>\n<tr>\n<td>headers</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>help</td>\n<td>sp_help</td>\n<td>N/A</td>\n<td>Get-Help, help, man</td>\n<td>man</td>\n</tr>\n<tr>\n<td>histogram</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>history</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-History, history</td>\n<td>history</td>\n</tr>\n<tr>\n<td>inc(<code>*</code>)</td>\n<td>N/A</td>\n<td></td>\n<td>N/A</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>insert</td>\n<td></td>\n<td></td>\n<td>Add-Member</td>\n<td></td>\n</tr>\n<tr>\n<td>is_empty</td>\n<td>is null</td>\n<td>String.InNullOrEmpty()</td>\n<td>String.InNullOrEmpty()</td>\n<td></td>\n</tr>\n<tr>\n<td>keep</td>\n<td>top,limit</td>\n<td>Take</td>\n<td>Select-Object -First</td>\n<td>head</td>\n</tr>\n<tr>\n<td>keep_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_while</td>\n<td></td>\n<td>TakeWhile</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Stop-Process, kill</td>\n<td>kill</td>\n</tr>\n<tr>\n<td>last</td>\n<td></td>\n<td>Last, LastOrDefault</td>\n<td>Select-Object -Last</td>\n<td>tail</td>\n</tr>\n<tr>\n<td>lines</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>File.ReadAllLines()</td>\n<td></td>\n</tr>\n<tr>\n<td>ls</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-ChildItem, dir, ls</td>\n<td>ls</td>\n</tr>\n<tr>\n<td>map_max_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>match(<code>*</code>)</td>\n<td>case when</td>\n<td>RegEx</td>\n<td>[regex]</td>\n<td></td>\n</tr>\n<tr>\n<td>merge</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>mkdir, md</td>\n<td>mkdir</td>\n</tr>\n<tr>\n<td>mv</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Move-Item, mv, move, mi</td>\n<td>mv</td>\n</tr>\n<tr>\n<td>next</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>nth</td>\n<td>limit x offset y, rownumber =</td>\n<td>ElemantAt(x)</td>\n<td>[x], indexing operator, ElementAt(x)</td>\n<td></td>\n</tr>\n<tr>\n<td>open</td>\n<td></td>\n<td></td>\n<td>Get-Content, gc, cat, type</td>\n<td>cat</td>\n</tr>\n<tr>\n<td>parse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pivot</td>\n<td>pivot</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>post(<code>*</code>)</td>\n<td>N/A</td>\n<td>HttpClient,WebClient, HttpWebRequest/Response</td>\n<td>Invoke-WebRequest</td>\n<td></td>\n</tr>\n<tr>\n<td>prepend</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prev</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ps(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-Process, ps, gps</td>\n<td>ps</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-Location, pwd</td>\n<td>pwd</td>\n</tr>\n<tr>\n<td>range</td>\n<td></td>\n<td>Range</td>\n<td>1..10, 'a'..'f'</td>\n<td></td>\n</tr>\n<tr>\n<td>reduce_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reject</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Rename-Item, ren, rni</td>\n<td>mv</td>\n</tr>\n<tr>\n<td>reverse</td>\n<td></td>\n<td>Reverse</td>\n<td>[Array]::Reverse($var)</td>\n<td></td>\n</tr>\n<tr>\n<td>rm</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Remove-Item, del, erase, rd, ri, rm, rmdir</td>\n<td>rm</td>\n</tr>\n<tr>\n<td>save</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Write-Output, Out-File</td>\n<td>&gt; foo.txt</td>\n</tr>\n<tr>\n<td>select(<code>***</code>)</td>\n<td>select</td>\n<td>Select</td>\n<td>Select-Object, select</td>\n<td></td>\n</tr>\n<tr>\n<td>shells</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td></td>\n<td>Random</td>\n<td>$var</td>\n<td>Sort-Object {Get-Random}</td>\n</tr>\n<tr>\n<td>size</td>\n<td></td>\n<td></td>\n<td>Measure-Object, measure</td>\n<td>wc</td>\n</tr>\n<tr>\n<td>skip</td>\n<td>where row_number()</td>\n<td>Skip</td>\n<td>Select-Object -Skip</td>\n<td></td>\n</tr>\n<tr>\n<td>skip_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_while</td>\n<td></td>\n<td>SkipWhile</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sort-by</td>\n<td>order by</td>\n<td>OrderBy, OrderByDescending, ThenBy, ThenByDescending</td>\n<td>Sort-Object, sort</td>\n<td></td>\n</tr>\n<tr>\n<td>split_by</td>\n<td></td>\n<td>String.Split()</td>\n<td>String.Split()</td>\n<td></td>\n</tr>\n<tr>\n<td>split_column</td>\n<td></td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_row</td>\n<td></td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>str(<code>*</code>)</td>\n<td>string functions</td>\n<td>String class</td>\n<td>String class</td>\n<td></td>\n</tr>\n<tr>\n<td>sum</td>\n<td>sum</td>\n<td>Sum()</td>\n<td>Measure-Object, measure</td>\n<td></td>\n</tr>\n<tr>\n<td>sys(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-ComputerInfo</td>\n<td>uname, lshw, lsblk, lscpu, lsusb, hdparam, free</td>\n</tr>\n<tr>\n<td>table</td>\n<td></td>\n<td></td>\n<td>Format-Table, ft, Format-List, fl</td>\n<td></td>\n</tr>\n<tr>\n<td>tags</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>textview(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-Content, cat</td>\n<td></td>\n</tr>\n<tr>\n<td>tree(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>tree</td>\n<td></td>\n</tr>\n<tr>\n<td>to bson</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to csv</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Export-Csv, ConvertTo-Csv</td>\n<td></td>\n</tr>\n<tr>\n<td>to html</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>ConvertTo-Html</td>\n<td></td>\n</tr>\n<tr>\n<td>to json</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>ConvertTo-Json</td>\n<td></td>\n</tr>\n<tr>\n<td>to md</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to sqlite</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to toml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to tsv</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to url</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to yaml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>touch</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Set-Content</td>\n<td>touch</td>\n</tr>\n<tr>\n<td>trim</td>\n<td>rtrim, ltrim</td>\n<td>String.Trim()</td>\n<td>String.Trim()</td>\n<td></td>\n</tr>\n<tr>\n<td>uniq</td>\n<td>distinct</td>\n<td>Distinct</td>\n<td>Get-Unique, gu</td>\n<td>uniq</td>\n</tr>\n<tr>\n<td>update(<code>**</code>)</td>\n<td>As</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>version</td>\n<td>select @@version</td>\n<td>N/A</td>\n<td>$PSVersionTable</td>\n<td></td>\n</tr>\n<tr>\n<td>with_env</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>$env:FOO = 'bar'</td>\n<td>export foo = &quot;bar&quot;</td>\n</tr>\n<tr>\n<td>what</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>where</td>\n<td>where</td>\n<td>Where</td>\n<td>Where-Object, where, &quot;?&quot; operator</td>\n<td></td>\n</tr>\n<tr>\n<td>which</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>which</td>\n</tr>\n<tr>\n<td>wrap</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>*</code> - Pertenecen de los plugins standard</li>\n<li><code>**</code> - renombrada de <code>edit</code> a <code>update</code> en 0.13.1</li>\n<li><code>***</code> - renombrada de <code>pick</code> a <code>select</code> en 0.13.1</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa de operadores en Nushell",
      "url": "www.nushell.sh/es/book/mapa_operador_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_operador_nushell.html",
      "content_html": "<h1 id=\"mapa-de-operadores-en-nushell\" tabindex=\"-1\"> Mapa de operadores en Nushell</h1>\n<p>La idea detrÃ¡s de esta tabla is ayudarte a entender como los operadores en Nu se relacionan con operadores de otros lenguajes. Hemos intentado producir un mapa de los operadores y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>SQL</th>\n<th>Python</th>\n<th>.Net LINQ (C#)</th>\n<th>PowerShell</th>\n<th>Bash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>=</td>\n<td>==</td>\n<td>==</td>\n<td>-eq, -is</td>\n<td>-eq</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>!=, &lt;&gt;</td>\n<td>!=</td>\n<td>!=</td>\n<td>-ne, -isnot</td>\n<td>-ne</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>&lt;</td>\n<td>&lt;</td>\n<td>&lt;</td>\n<td>-lt</td>\n<td>-lt</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>&lt;=</td>\n<td>&lt;=</td>\n<td>&lt;=</td>\n<td>-le</td>\n<td>-le</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>&gt;</td>\n<td>&gt;</td>\n<td>&gt;</td>\n<td>-gt</td>\n<td>-gt</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>&gt;=</td>\n<td>&gt;=</td>\n<td>&gt;=</td>\n<td>-ge</td>\n<td>-ge</td>\n</tr>\n<tr>\n<td>=~</td>\n<td>like</td>\n<td>re, in, startswith</td>\n<td>Contains, StartsWith</td>\n<td>-like, -contains</td>\n<td>=~</td>\n</tr>\n<tr>\n<td>!~</td>\n<td>not like</td>\n<td>not in</td>\n<td>Except</td>\n<td>-notlike, -notcontains</td>\n<td>! &quot;str1&quot; =~ &quot;str2&quot;</td>\n</tr>\n<tr>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n</tr>\n<tr>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n</tr>\n<tr>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n</tr>\n<tr>\n<td>in</td>\n<td>in</td>\n<td>re, in, startswith</td>\n<td>Contains, StartsWith</td>\n<td>-In</td>\n<td>case in</td>\n</tr>\n<tr>\n<td>not-in</td>\n<td>not in</td>\n<td>not in</td>\n<td>Except</td>\n<td>-NotIn</td>\n<td></td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>and</td>\n<td>and</td>\n<td>&amp;&amp;</td>\n<td>-And</td>\n<td>-a, &amp;&amp;</td>\n</tr>\n<tr>\n<td>||</td>\n<td>or</td>\n<td>or</td>\n<td>||</td>\n<td>-Or</td>\n<td>-o, ||</td>\n</tr>\n</tbody>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "MatemÃ¡ticas",
      "url": "www.nushell.sh/es/book/matematicas.html",
      "id": "www.nushell.sh/es/book/matematicas.html",
      "content_html": "<h1 id=\"matematicas\" tabindex=\"-1\"> MatemÃ¡ticas</h1>\n<p>Hay veces que simplemente necesitas sumar un par de nÃºmeros cuando te encuentras resolviendo problemas. Nu ofrece un conjunto de operaciones matemÃ¡ticas bÃ¡sicas que puedes utilizar. Expresiones matemÃ¡ticas se encuentran disponibles cuando llamas a un comando.</p>\n<h2 id=\"sumar-restar-mupltiplicar-dividir\" tabindex=\"-1\"> Sumar, Restar, Mupltiplicar, Dividir</h2>\n<div><pre><code>> 1 + 3\n4\n</code></pre></div><p>En Nu puedes realizar lo usual: sumar, restar, mutiplicar y dividir con los operadores <code>+</code>, <code>-</code>, <code>*</code>, y <code>/</code> respectivamente. Precedencia de operadores es respetada, por lo que <code>1 + 2 * 3</code> serÃ¡ tratado como <code>1 + (2 * 3)</code>. Lo que nos lleva a parÃ©ntesis.</p>\n<h2 id=\"parentesis\" tabindex=\"-1\"> ParÃ©ntesis</h2>\n<p>Puedes usar parÃ©ntesis para agrupar expresiones matemÃ¡ticas en modo <code>math</code>. Esto te permite escribir <code>(1 + 2) * 3</code> si deseas que adiciÃ³n tenga mayor precedencia.</p>\n<h2 id=\"in-y-not-in\" tabindex=\"-1\"> <code>in</code> y <code>not-in</code></h2>\n<p>Puedes revisar si un valor se encuentra dentro de un conjunto de valores o no, usando los operadores <code>in</code> y <code>not-in</code>.</p>\n<div><pre><code>> 1 in [1 2 3]\ntrue\n</code></pre></div><div><pre><code>> 1 not-in [1 2 3]\nfalse\n</code></pre></div><h2 id=\"y\" tabindex=\"-1\"> =~ y !~</h2>\n<p>Puedes revisar si una cadena se encuentra dentro de otra cadena o no, usando <code>=~</code> y <code>!~</code>.</p>\n<div><pre><code>> \"gallinagallo\" =~ \"gallo\"\ntrue\n</code></pre></div><div><pre><code>> \"gallinagallo\" !~ \"pollito\"\ntrue\n</code></pre></div><h2 id=\"comparaciones\" tabindex=\"-1\"> Comparaciones</h2>\n<p>Los siguientes comparadores tambiÃ©n se encuentran disponibles:</p>\n<ul>\n<li><code>&lt;</code> - menor que</li>\n<li><code>&lt;=</code> - menor o igual que</li>\n<li><code>&gt;</code> - mayor que</li>\n<li><code>&gt;=</code> - mayor o igual que</li>\n<li><code>==</code> - igual a</li>\n<li><code>!=</code> - no es igual a</li>\n</ul>\n<h2 id=\"operadores-compuestos\" tabindex=\"-1\"> Operadores Compuestos</h2>\n<p>Nushell tambiÃ©n soporta <code>&amp;&amp;</code> y <code>||</code> para unir dos operaciones que regresen valores booleanos, usando <code>y</code> y <code>o</code> respectivamente. Por ejemplo: <code>ls | where name in [&quot;uno&quot; &quot;dos&quot; &quot;tres&quot;] &amp;&amp; size &gt; 10kb</code></p>\n<h2 id=\"orden-de-operaciones\" tabindex=\"-1\"> Orden de operaciones</h2>\n<p>Las operaciones matemÃ¡ticas son evaluadas de la siguiente manera (de mayor precedencia a menor):</p>\n<ul>\n<li>Parentesis (<code>()</code>)</li>\n<li>MultiplicaciÃ³n (<code>*</code>) y DivisiÃ³n (<code>/</code>)</li>\n<li>Suma (<code>+</code>) y Resta (<code>-</code>)</li>\n</ul>\n<div><pre><code>> 3 * (1 + 2)\n9\n</code></pre></div><h2 id=\"modo-matematico-abreviado\" tabindex=\"-1\"> Modo matemÃ¡tico abreviado</h2>\n<p>Hay una variaciÃ³n abreviada &quot;short-hand&quot; en modo matemÃ¡tico incluÃ­da en Nushell. La razÃ³n se debe a que permite una forma de acceder columnas de manera mÃ¡s simple.</p>\n<p>Es probable que ya la usaste antes. Por ejemplo, supongamos que deseamos ver filas de <code>ls</code> donde para cada uno por lo menos tenga 10 kilobytes, podemos escribir:</p>\n<div><pre><code>> ls | where size > 10kb\n</code></pre></div><p>El comando <code>where memoria &gt; 10kb</code> tiene dos partes: El nombre del comando <code>where</code> y su abreviaciÃ³n expresiÃ³n matemÃ¡tica <code>size &gt; 10kb</code>. Indicamos <code>abreviada</code> debido a que <code>size</code> es una versiÃ³n acortada de escribir <code>$it.size</code>. Si observamos su forma completamente expandida, verÃ­amos:</p>\n<div><pre><code>> ls | where {|$it| $it.size > 10kb }\n</code></pre></div><p>Usamos el modo abreviado para trabajar con datos de columnas para no tener que repetir la forma expandida siempre.</p>\n<p>Para el funcionamiento apropiado de la abreviaciÃ³n acortada y por lo tanto su expansiÃ³n, el nombre de la columna tiene que aparecer en el lado izquierdo de la operaciÃ³n. Arriba, <code>size</code> aparece en en lado izquierdo de la comparaciÃ³n que permite la expresiÃ³n expanderse al modo completo matemÃ¡tico del bloque.</p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Metadatos",
      "url": "www.nushell.sh/es/book/metadatos.html",
      "id": "www.nushell.sh/es/book/metadatos.html",
      "content_html": "<h1 id=\"metadatos\" tabindex=\"-1\"> Metadatos</h1>\n<p>Al usar Nu es posible que hayan momentos que has encontrado como si algo extra sucediera detrÃ¡s de escenas. Por ejemplo digamos que intentas abrir un archivo soportado por Nu para luego olvidarte e intentar convertir nuevamente:</p>\n<div><pre><code>> open Cargo.toml | from toml\nerror: Expected a string from pipeline\n- shell:1:18\n1 | open Cargo.toml | from toml\n  |                   ^^^^^^^^^ requires string input\n- shell:1:5\n1 | open Cargo.toml | from toml\n  |      ---------- object originates from here\n</code></pre></div><p>El mensaje de error nos indica que hemos proporcionado a <code>from toml</code> algo distinto a una cadena pero tambiÃ©n el origen del valor. Â¿CÃ³mo puede saberlo?</p>\n<p>Valores que fluyen a travÃ©s de la tuberÃ­a en Nu comÃºnmente disponen de informaciÃ³n adicional (o metadatos) adjuntadas en las mismas. Se conocen como etiquetas como las etiquetas en una tienda. Estas etiquetas no afecta los datos pero permiten a Nu mejorar la experiencia mientras se trabaja con esos datos.</p>\n<p>Nuevamente ejecutemos el comando <code>open</code> pero esta vez observaremos las etiquetas que nos devuelve:</p>\n<div><pre><code>> open Cargo.toml | tags\n----------+------------------------------------------\n span     | anchor\n----------+------------------------------------------\n [object] | /home/jonathan/Source/nushell/Cargo.toml\n----------+------------------------------------------\n</code></pre></div><p>Actualmente rastreamos dos pedazos de metadatos de los valores en la tuberÃ­a. Puedes darte cuenta que disponemos del ancla que nos da la ubicaciÃ³n de dÃ³nde se cargaron los datos. Esto puede ayudar a Nu entender mejor como presentar datos.</p>\n<p>TambiÃ©n hay lapso (span). Miremos mÃ¡s de cerca a eso:</p>\n<div><pre><code>> open Cargo.toml | tags | get span\n-------+-----\n start | end\n-------+-----\n 5     | 15\n-------+-----\n</code></pre></div><p>El lapso &quot;start&quot; y &quot;end&quot; aquÃ­ se refiere en dÃ³nde estarÃ¡ el subrayado en la lÃ­nea. Si cuentas a partir de 5 y luego hasta 15 podrÃ¡s observar que se alinea con el nombre de archivo &quot;Cargo.toml&quot;. AsÃ­ es como Nu sabÃ­a quÃ© subrayar apropiadamente en el error que vimos previamente.</p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "El pipeline",
      "url": "www.nushell.sh/es/book/pipeline.html",
      "id": "www.nushell.sh/es/book/pipeline.html",
      "content_html": "<h1 id=\"el-pipeline\" tabindex=\"-1\"> El pipeline</h1>\n<p>Uno de los diseÃ±os centrales de Nu es la tuberÃ­a (pipeline), una idea de diseÃ±o que rastrea sus raÃ­ces dÃ©cadas atrÃ¡s hasta parte de la filosofÃ­a original detrÃ¡s de Unix. AsÃ­ como Nu extiende desde un solo dato tipo de cadena de Unix, Nu tambiÃ©n extiende la idea de tuberÃ­as (pipelines) para incluir mÃ¡s que solo texto.</p>\n<h2 id=\"fundamentos\" tabindex=\"-1\"> Fundamentos</h2>\n<p>Una tuberÃ­a (pipeline) es construÃ­da con tres partes: la entrada, el filtro, y la salida.</p>\n<div><pre><code>> open \"Cargo.toml\" | inc package.version | save \"Cargo_new.toml\"\n</code></pre></div><p>El primer comando, <code>open &quot;Cargo.toml&quot;</code>, es una entrada (a veces tambiÃ©n llamada &quot;fuente&quot; o &quot;productor&quot;). Esto crea o carga datos y lo canaliza en la tuberÃ­a. Es de entrada para la tuberÃ­a tener valores y poder trabajarlas. Comandos como <code>ls</code> tambiÃ©n son entradas ya que toman datos desde el sistema de archivos y lo canalizan a travÃ©s de las tuberÃ­as para que puedan ser usadas.</p>\n<p>El segundo comando, <code>inc package.version</code>, es un filtro. Filtros toman los datos que se les entrega y comÃºnmente hacen algo con la misma. Puede que la cambien (tal como el comando <code>inc</code> en nuestro ejemplo), o pueden hacer otra operaciÃ³n, como registrar, mientras pasan los valores.</p>\n<p>El Ãºltimo comando, <code>save &quot;Cargo_new.toml&quot;</code>, es una salida (a veces llamado un &quot;sink&quot;). Una salida toma la entrada de la tuberÃ­a y realiza alguna operaciÃ³n final. En nuestro ejemplo, grabamos lo que viene a travÃ©s de la tuberÃ­a hacia un archivo como paso final. Otros tipos de comandos de salida pueda que tomen valores y lo muestren para el usuario.</p>\n<h2 id=\"trabajando-con-comandos-externos\" tabindex=\"-1\"> Trabajando con comandos externos</h2>\n<p>Los comandos en Nu se comunican entre ellos usando los tipos de datos de Nu (mirar <a href=\"/es/book/tipos_de_datos.html\">tipos de datos</a>) pero, Â¿quÃ© hay de comandos fuera de Nu? Miremos algunos ejemplos trabajando con comandos externos:</p>\n<p><code>commando_interno | comando_externo</code></p>\n<p>Los datos fluirÃ¡n desde comando_interno al comando_externo. Estos datos se esperan que sean cadenas para que puedan ser enviadas a entrada estÃ¡ndar <code>stdin</code> del comando_externo.</p>\n<p><code>comando_externo | comando_interno</code></p>\n<p>Los datos que vienen de un comando externo a Nu se coleccionarÃ¡ a una sola cadena y luego serÃ¡n pasadas a comando_interno. Comandos como <code>lines</code> ayudan a facilitar datos provenientes de comandos externos de manera que sea mÃ¡s facil trabajarlas.</p>\n<p><code>comando_externo_1 | comando_externo_2</code></p>\n<p>Nu trabaja con datos canalizados entre dos comandos externos de la misma forma como en otras shells, como Bash lo harÃ­a. La salida estÃ¡ndar <code>stdout</code> de comando_externo_1 es conectada a la entrada estÃ¡ndar <code>stdin</code> de comando_externo_2. Esto permite que los datos fluyan naturalmente entre dos comandos.</p>\n<h2 id=\"detras-de-escenas\" tabindex=\"-1\"> DetrÃ¡s de escenas</h2>\n<p>Es posible que te hayas preguntado como miramos una tabla si <code>ls</code> es una entrada y no una salida. Nu agrega esta salida por nosotros automÃ¡ticamente usando otro comando llamado <code>autoview</code>. El comando <code>autoview</code> es aÃ±adido a cualquier tuberÃ­a que no tenga una salida permitiÃ©ndonos ver el resultado.</p>\n<p>En efecto, el comando:</p>\n<div><pre><code>> ls\n</code></pre></div><p>y la tuberÃ­a:</p>\n<div><pre><code>> ls | autoview\n</code></pre></div><p>Son uno y lo mismo.</p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Complementos (plugins)",
      "url": "www.nushell.sh/es/book/plugins.html",
      "id": "www.nushell.sh/es/book/plugins.html",
      "content_html": "<h1 id=\"complementos-plugins\" tabindex=\"-1\"> Complementos (plugins)</h1>\n<p>Se puede ampliar la funcionalidad de Nu a travÃ©s de complementos. Los complementos pueden realizar muchas de las mismas operaciones que los comandos integrados de Nu con el beneficio adicional de que se pueden agregar separado de Nu.</p>\n<p>Para agregar un complemento simplemente compÃ­lalo y colÃ³ca el binario en el PATH. Los complementos de Nu empiezan con <code>nu_plugin_</code> de manera que Nu pueda encontrarlos entre otros binarios en su PATH.</p>\n<p><strong>Nota:</strong> en el futuro los complementos pueden que tengan un lugar especÃ­fico que deban ser puestos para Nu encontrarlos.</p>\n<p>CuÃ¡ndo Nu arranca escanea el sistema y carga los complementos que encuentre.</p>\n<p>El protocolo que usan los complementos de Nu estÃ¡ sujetos a cambios mientras Nu estÃ¡ bajo fuerte desarrollo. El mejor lugar para aprender mÃ¡s sobre el protocolo y cÃ³mo crear tus propios complementos es leyendo el cÃ³digo fuente de los <a href=\"https://github.com/nushell/nushell/tree/master/crates\" target=\"_blank\" rel=\"noopener noreferrer\">complementos en el repositorio de Nu</a>. TambiÃ©n puedes dirigirte al <a href=\"https://github.com/nushell/contributor-book/blob/master/en/plugins.md\" target=\"_blank\" rel=\"noopener noreferrer\">capÃ­tulo de plugins en el manual para contribuyentes de Nu</a></p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Shells en shells",
      "url": "www.nushell.sh/es/book/shells_en_shells.html",
      "id": "www.nushell.sh/es/book/shells_en_shells.html",
      "content_html": "<h1 id=\"shells-en-shells\" tabindex=\"-1\"> Shells en shells</h1>\n<h2 id=\"trabajando-con-multiples-directorios\" tabindex=\"-1\"> Trabajando con mÃºltiples directorios</h2>\n<p>Mientras es comÃºn trabajar en un directorio puede ser beneficioso trabajar en mÃºltiples lugares al mismo tiempo. Para esto Nu ofrece el concepto de &quot;shells&quot;. Tal como implica, son una manera de tener activo mÃºltiples shells en uno permitiendote rÃ¡pidamente saltar entre directorios de trabajo y mÃ¡s.</p>\n<p>Para empezar entremos a un directorio:</p>\n<div><pre><code>/home/jonathan/Source/nushell(master)> enter ../lark\n/home/jonathan/Source/lark(master)> ls\n----+----------------+-----------+----------+---------+---------------+---------------\n #  | name           | type      | readonly | size    | accessed      | modified\n----+----------------+-----------+----------+---------+---------------+---------------\n 0  | Cargo.toml     | File      |          | 2.2 KB  | 6 months ago  | 6 months ago\n 1  | target         | Directory |          | 4.1 KB  | 10 months ago | 6 months ago\n 2  | notes          | Directory |          | 4.1 KB  | 10 months ago | 6 months ago\n</code></pre></div><p>Entrar es similar a cambiar directorios (como vimos previamente con el comando <code>cd</code>). Esto permite saltar al directorio para trabajar dentro del mismo. En lugar de cambiar de directorio, ahora estamos en dos directorios. Para ver esto con mÃ¡s claridad podemos usar el comando <code>shells</code> que enumera los directorios actualmente activos:</p>\n<div><pre><code>/home/jonathan/Source/lark(master)> shells\n---+---+------------+-------------------------------\n # |   | name       | path\n---+---+------------+-------------------------------\n 0 |   | filesystem | /home/jonathan/Source/nushell\n 1 | X | filesystem | /home/jonathan/Source/lark\n---+---+------------+-------------------------------\n</code></pre></div><p>El comando <code>shells</code> nos muestra que hay dos shells activos: nuestro directorio fuente original &quot;nushell&quot; y ahora este nuevo directorio &quot;lark&quot;.</p>\n<p>Podemos saltar entre estas shells con los accesos directos <code>n</code> y <code>p</code>, cortos de siguiente &quot;next&quot; y previo &quot;previous&quot;:</p>\n<div><pre><code>/home/jonathan/Source/lark(master)> n\n/home/jonathan/Source/nushell(master)> p\n/home/jonathan/Source/lark(master)>\n</code></pre></div><p>Podemos notar el directorio cambiando pero tambiÃ©n siempre podremos regresar al directorio previo en el cual estÃ¡bamos trabajando. Esto nos permite trabajar en mÃºltiples directorio en la misma sesiÃ³n.</p>\n<h2 id=\"saliendo-del-shell\" tabindex=\"-1\"> Saliendo del shell</h2>\n<p>Puedes salir de una shell que hayas entrado (usando <code>enter</code>) a travÃ©s del comando <code>exit</code>. Si esta es la Ãºltima shell, Nu se cerrarÃ¡.</p>\n<p>Siempre puedes cerrar Nu incluso si tienes mÃºltiples shells activas usando el comando <code>exit</code> pasando la bandera <code>--now</code> de la siguiente forma <code>exit --now</code></p>\n<h2 id=\"mas-alla-de-los-directorios\" tabindex=\"-1\"> MÃ¡s allÃ¡ de los directorios</h2>\n<p>Nu tambiÃ©n puede crear shells de otras cosas aparte de las rutas del sistema de archivos. Digamos por ejemplo que estÃ¡s trabajando con un gran conjunto de datos y no deseas perderte dentro del mismo.</p>\n<p>Para ver cÃ³mo funciona haremos el siguiente ejercicio. Actualmente en Nu tenemos enumerados los <a href=\"/es/book/plugins.html\">complementos</a> desarrollados (plugins) en &quot;Cargo.toml&quot; digamos que tambiÃ©n acabamos de crear un nuevo complemento en el directorio src/plugins llamado &quot;doc.rs&quot; y nos interesa saber que se encuentre enumerado tambiÃ©n en &quot;Cargo.toml&quot; para que se instale al compilar Nu.</p>\n<p>Entraremos al archivo &quot;Cargo.toml&quot; del cÃ³digo fuente de Nu:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell(master)> enter Cargo.toml\n/> ls\n------------+--------------+------------------+----------+----------\n bin        | dependencies | dev-dependencies | lib      | package\n------------+--------------+------------------+----------+----------\n [11 items] | [object]     | [object]         | [object] | [object]\n------------+--------------+------------------+----------+----------\n</code></pre></div><p>Por el momento solo hemos entrado al archivo y podemos observar en la tabla devuelta por <code>ls</code> lo que hay. Si prestas atenciÃ³n hemos entrado a un archivo con formato que reconoce Nu (.toml). Nu tambiÃ©n nos proyecta el contenido del archivo en forma de sistema de archivos para explorarlo como si estuvieramos dentro de un sistema de archivos.</p>\n<p>Antes de continuar revisemos las shells activas:</p>\n<div><pre><code>/> shells\n---+---+-------------------------------------------------+------------------------------------\n # |   | name                                            | path\n---+---+-------------------------------------------------+------------------------------------\n 0 |   | filesystem                                      | /Users/andresrobalino/Code/nushell\n 1 | X | {/Users/andresrobalino/Code/nushell/Cargo.toml} | /\n---+---+-------------------------------------------------+------------------------------------\n\n</code></pre></div><p>Observamos que hay dos activas indicÃ¡ndonos que nos encontramos dentro de &quot;Cargo.toml&quot; en la ruta predeterminada &quot;/&quot;. Revisemos el listado de nuevo:</p>\n<div><pre><code>/> ls\n------------+--------------+------------------+----------+----------\n bin        | dependencies | dev-dependencies | lib      | package\n------------+--------------+------------------+----------+----------\n [11 items] | [object]     | [object]         | [object] | [object]\n------------+--------------+------------------+----------+----------\n</code></pre></div><p>Puede que los complementos se encuentren en &quot;bin&quot;, vamos ahÃ­:</p>\n<div><pre><code>> cd bin\n/bin> ls\n----+----------------------+---------------------------\n #  | name                 | path\n----+----------------------+---------------------------\n 0  | nu_plugin_inc        | src/plugins/inc.rs\n 1  | nu_plugin_sum        | src/plugins/sum.rs\n 2  | nu_plugin_add        | src/plugins/add.rs\n 3  | nu_plugin_edit       | src/plugins/edit.rs\n 4  | nu_plugin_str        | src/plugins/str.rs\n 5  | nu_plugin_skip       | src/plugins/skip.rs\n 6  | nu_plugin_sys        | src/plugins/sys.rs\n 7  | nu_plugin_tree       | src/plugins/tree.rs\n 8  | nu_plugin_binaryview | src/plugins/binaryview.rs\n 9  | nu_plugin_textview   | src/plugins/textview.rs\n 10 | nu                   | src/main.rs\n----+----------------------+---------------------------\n</code></pre></div><p>Notar que siempre podemos saltar de vuelta al directorio en el que estuvimos trabajando usando <code>p</code> (para previo).</p>\n<div><pre><code>/bin> p\n</code></pre></div><p>Verifiquemos las shells:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell(master)> shells\n---+---+-------------------------------------------------+------------------------------------\n # |   | name                                            | path\n---+---+-------------------------------------------------+------------------------------------\n 0 | X | filesystem                                      | /Users/andresrobalino/Code/nushell\n 1 |   | {/Users/andresrobalino/Code/nushell/Cargo.toml} | /bin\n---+---+-------------------------------------------------+------------------------------------\n\n</code></pre></div><p>Nos encontramos ahora en la shell donde estuvimos antes de entrar al archivo &quot;Cargo.toml&quot;, vamos al directorio donde se encuentra el cÃ³digo fuente de los complementos (plugins):</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell(master)> cd src/plugins/\n/Users/andresrobalino/Code/nushell/src/plugins(master)> ls\n----+---------------+------+----------+---------+------------+------------\n #  | name          | type | readonly | size    | accessed   | modified\n----+---------------+------+----------+---------+------------+------------\n 0  | doc.rs        | File |          | 3.0 KB  | a week ago | a week ago\n 1  | sum.rs        | File |          | 3.0 KB  | a week ago | a week ago\n 2  | inc.rs        | File |          | 11.8 KB | a week ago | a week ago\n 3  | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n 4  | edit.rs       | File |          | 2.7 KB  | a week ago | a week ago\n 5  | str.rs        | File |          | 21.4 KB | 5 days ago | 5 days ago\n 6  | secret.rs     | File |          | 1.8 KB  | 2 days ago | 2 days ago\n 7  | skip.rs       | File |          | 1.7 KB  | a week ago | a week ago\n 8  | binaryview.rs | File |          | 13.0 KB | a week ago | a week ago\n 9  | tree.rs       | File |          | 3.0 KB  | a week ago | a week ago\n 10 | add.rs        | File |          | 2.7 KB  | a week ago | a week ago\n 11 | textview.rs   | File |          | 9.4 KB  | 5 days ago | 5 days ago\n----+---------------+------+----------+---------+------------+------------\n</code></pre></div><p>Ahora podemos comparar los dos para verificar si faltan complementos adicionales o si hay complementos adicionales que necesitemos agregar a nuestro archivo &quot;Cargo.toml&quot; (Â¡y claramente falta agregarlo a &quot;Cargo.toml&quot;!)</p>\n",
      "date_modified": "2022-06-02T15:48:22.693Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Tipos de datos",
      "url": "www.nushell.sh/es/book/tipos_de_datos.html",
      "id": "www.nushell.sh/es/book/tipos_de_datos.html",
      "content_html": "<h1 id=\"tipos-de-datos\" tabindex=\"-1\"> Tipos de datos</h1>\n<p>Tradicionalmente, comandos shell de Unix se han comunidado entre ellos usando cadenas de texto. Un comando generarÃ­a de salida texto a travÃ©s de la salida estÃ¡ndar (comÃºnmente abreviada 'stdout') y el otro leer texto a travÃ©s de la entrada estÃ¡ndar (o 'stdin').</p>\n<p>Podemos pensar de este tipo de comunicaciÃ³n como basada en cadenas.</p>\n<p>Nu adopta este enfoque para sus comandos y lo hacer crecer para incluir otro tipos de datos. Actualmente, Nu incluye soporte para dos tipos de datos: simple y estructurada.</p>\n<h2 id=\"datos-simples\" tabindex=\"-1\"> Datos simples</h2>\n<p>Al igual que muchos lenguajes de programaciÃ³n, Nu modela los datos usando un conjunto de tipos de datos simples y estructurados. Tipos de dato simple incluye enteros, decimales, cadenas, booleanos, fechas, y rutas. TambiÃ©n incluye un tipo especial para tamaÃ±os de archivos.</p>\n<h3 id=\"enteros\" tabindex=\"-1\"> Enteros</h3>\n<p>Enteros (o redondos). Ejemplos incluye 1, 5, y 100.</p>\n<h3 id=\"decimales\" tabindex=\"-1\"> Decimales</h3>\n<p>NÃºmeros decimales son nÃºmeros con algÃºn component fraccional. Ejemplos incluye 1.5, 2.0, y 15.333.</p>\n<h3 id=\"cadenas\" tabindex=\"-1\"> Cadenas</h3>\n<p>Las cadenas son la manera fundamental de representar texto. Se indican con doble comillas. Ejemplos incluye &quot;Pedro&quot;, &quot;minombre.txt&quot;, and &quot;Lynchburg, VA&quot;.</p>\n<p>Cadenas en Nu son compatibles con Unicode de manera predeterminada, por lo que puedes pasar texto UTF-8 con facilidad.</p>\n<h3 id=\"booleanos\" tabindex=\"-1\"> Booleanos</h3>\n<p>Booleanos son el estado de verdadero o falso. En vez de escribir el valor directamente, comÃºnmente es el resultado de una comparaciÃ³n.</p>\n<h3 id=\"fechas\" tabindex=\"-1\"> Fechas</h3>\n<p>Fechas y horas se mantienen juntas en el valor tipo de dato Date. Valores Date usados por el sistema reconocen la zona horaria y de manera predeterminada usa la zona horaria UTC.</p>\n<h3 id=\"rutas\" tabindex=\"-1\"> Rutas</h3>\n<p>Las rutas son una forma independiente de la plataforma para representar rutas de archivos en el sistema operativo dado. Ejemplos incluyen: /usr/bin y C:\\Users\\archivo.txt.</p>\n<h3 id=\"bytes\" tabindex=\"-1\"> Bytes</h3>\n<p>TamaÃ±os de archivos se mantienen dentro de un tipo especial de entero llamado bytes. Ejemplos incluye 100, 15kb, y 100mb.</p>\n<h2 id=\"datos-estructurados\" tabindex=\"-1\"> Datos estructurados</h2>\n<p>Los datos estructurados se construyen a partir de los datos simples. Por ejemplo, en lugar de un solo entero, datos estructurados nos ofrece una manera de representar mÃºltiples enteros en el mismo valor. Esta es una lista actual de los tipos de dato estructurados soportadas: objetos, datos binarios, listas, y bloques.</p>\n<h3 id=\"objetos\" tabindex=\"-1\"> Objetos</h3>\n<p>El tipo de dato object representa lo que observarÃ­as en una fila de datos de una tabla. Tiene diferentes elementos de datos y cada elemento de dato se le asigna un nombre de columna.</p>\n<h3 id=\"datos-binarios\" tabindex=\"-1\"> Datos binarios</h3>\n<p>Datos binarios como los datos de un archivo de imagen, es un grupo de bytes sin formato.</p>\n<h3 id=\"listas\" tabindex=\"-1\"> Listas</h3>\n<p>Las listas pueden tener mÃ¡s de un valor. Esto les permite ser un buen contenedor de filas de datos de una tabla.</p>\n<h3 id=\"bloques\" tabindex=\"-1\"> Bloques</h3>\n<p>Bloques representan bloques de cÃ³digo en Nu. Por ejemplo, en el comando <code>where { $it.size &gt; 10kb }</code> el bloque es la porciÃ³n contenida en las llaves, <code>{ $it.size &gt; 10kb }</code>. Los bloques son una manera Ãºtil de representar cÃ³digo que puede ser ejecutado para cada fila de datos.</p>\n",
      "date_modified": "2022-06-02T15:48:22.693Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Trabajando con tablas",
      "url": "www.nushell.sh/es/book/trabajando_con_tablas.html",
      "id": "www.nushell.sh/es/book/trabajando_con_tablas.html",
      "content_html": "<h1 id=\"trabajando-con-tablas\" tabindex=\"-1\"> Trabajando con tablas</h1>\n<p>Una de las maneras comunes de mirar datos en Nu es a travÃ©s de una tabla. Nu viene con una serie de comandos que trabajan con tablas para que pueda ser mÃ¡s conveniente encontrar lo que estÃ¡s buscando y para limitar los datos a solo lo que necesites.</p>\n<p>Para empezar, consigamos una tabla que podamos usar:</p>\n<div><pre><code>> ls\n---+---------------+------+----------+---------+------------+------------\n # | name          | type | readonly | size    | accessed   | modified\n---+---------------+------+----------+---------+------------+------------\n 0 | add.rs        | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 1 | sum.rs        | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 2 | inc.rs        | File |          | 11.8 KB | 2 days ago | 2 days ago\n 3 | str.rs        | File |          | 21.4 KB | 2 days ago | 2 days ago\n 4 | skip.rs       | File |          | 1.7 KB  | 2 days ago | 2 days ago\n 5 | textview.rs   | File |          | 9.4 KB  | 2 days ago | 2 days ago\n 6 | binaryview.rs | File |          | 13.0 KB | a day ago  | a day ago\n 7 | edit.rs       | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 8 | tree.rs       | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 9 | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n---+---------------+------+----------+---------+------------+------------\n</code></pre></div><h2 id=\"ordenando-los-datos\" tabindex=\"-1\"> Ordenando los datos</h2>\n<p>Podemos ordenar la tabla llamando el comando <code>sort-by</code> e indicÃ¡ndole quÃ© columnas queremos usar al ordenar. Digamos que deseamos ordenar nuestra tabla por tamaÃ±o de archivo:</p>\n<div><pre><code>> ls | sort-by size\n---+---------------+------+----------+---------+------------+------------\n # | name          | type | readonly | size    | accessed   | modified\n---+---------------+------+----------+---------+------------+------------\n 0 | skip.rs       | File |          | 1.7 KB  | 2 days ago | 2 days ago\n 1 | add.rs        | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 2 | edit.rs       | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 3 | sum.rs        | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 4 | tree.rs       | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 5 | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n 6 | textview.rs   | File |          | 9.4 KB  | 2 days ago | 2 days ago\n 7 | inc.rs        | File |          | 11.8 KB | 2 days ago | 2 days ago\n 8 | binaryview.rs | File |          | 13.0 KB | a day ago  | a day ago\n 9 | str.rs        | File |          | 21.4 KB | 2 days ago | 2 days ago\n---+---------------+------+----------+---------+------------+------------\n</code></pre></div><p>Podemos ordenar una tabla con cualquier columna que pueda ser comparada. Por ejemplo, tambiÃ©n pudimos haber ordenador usando las columnas &quot;name&quot;, &quot;accessed&quot;, o &quot;modified&quot;.</p>\n<h1 id=\"seleccionando-los-datos-que-quieres\" tabindex=\"-1\"> Seleccionando los datos que quieres</h1>\n<p>Podemos seleccionar datos de una tabla seleccionando columnas o filas especÃ­ficas. Escojamos algunas columnas de nuestra tabla para usar:</p>\n<div><pre><code>> ls | select name size\n---+---------------+---------\n # | name          | size\n---+---------------+---------\n 0 | add.rs        | 2.7 KB\n 1 | sum.rs        | 3.0 KB\n 2 | inc.rs        | 11.8 KB\n 3 | str.rs        | 21.4 KB\n 4 | skip.rs       | 1.7 KB\n 5 | textview.rs   | 9.4 KB\n 6 | binaryview.rs | 13.0 KB\n 7 | edit.rs       | 2.7 KB\n 8 | tree.rs       | 3.0 KB\n 9 | sys.rs        | 9.2 KB\n---+---------------+---------\n</code></pre></div><p>Esto ayuda a crear una table mÃ¡s enfocada para lo que necesitamos. Siguiente, digamos que queremos ver los 5 archivos mÃ¡s livianos de este directorio:</p>\n<div><pre><code>> ls | sort-by size | first 5\n---+---------+------+----------+--------+------------+------------\n # | name    | type | readonly | size   | accessed   | modified\n---+---------+------+----------+--------+------------+------------\n 0 | skip.rs | File |          | 1.7 KB | 2 days ago | 2 days ago\n 1 | add.rs  | File |          | 2.7 KB | 2 days ago | 2 days ago\n 2 | edit.rs | File |          | 2.7 KB | 2 days ago | 2 days ago\n 3 | sum.rs  | File |          | 3.0 KB | 2 days ago | 2 days ago\n 4 | tree.rs | File |          | 3.0 KB | 2 days ago | 2 days ago\n---+---------+------+----------+--------+------------+------------\n</code></pre></div><p>NotarÃ¡s que primero ordenamos la tabla por tamaÃ±o para llegar hasta el archivo mÃ¡s pequeÃ±o y luego usamos <code>first 5</code> que nos devuelve las primeras 5 filas de la tabla.</p>\n<p>TambiÃ©n puedes saltarte filas con <code>skip</code> que no deseas. Saltemos las primeras dos de las 5 filas que obtuvimos arriba:</p>\n<div><pre><code>> ls | sort-by size | first 5 | skip 2\n---+---------+------+----------+--------+------------+------------\n # | name    | type | readonly | size   | accessed   | modified\n---+---------+------+----------+--------+------------+------------\n 0 | edit.rs | File |          | 2.7 KB | 2 days ago | 2 days ago\n 1 | sum.rs  | File |          | 3.0 KB | 2 days ago | 2 days ago\n 2 | tree.rs | File |          | 3.0 KB | 2 days ago | 2 days ago\n---+---------+------+----------+--------+------------+------------\n</code></pre></div><p>Hemos reducido a tres filas que nos interesa.</p>\n<p>Veamos algunos otros comandos para seleccionar datos. Es posible que te hayas preguntado por quÃ© las filas de la tabla son nÃºmeros. Esto actÃºa como una forma prÃ¡ctica de llegar a una sola fila. Ordenemos nuestra tabla por el nombre del archivo y luego escojamos una de las filas con el comando <code>n-th</code> usando el nÃºmero de fila:</p>\n<div><pre><code>> ls | sort-by name\n---+---------------+------+----------+---------+------------+------------\n # | name          | type | readonly | size    | accessed   | modified\n---+---------------+------+----------+---------+------------+------------\n 0 | add.rs        | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 1 | binaryview.rs | File |          | 13.0 KB | a day ago  | a day ago\n 2 | edit.rs       | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 3 | inc.rs        | File |          | 11.8 KB | 2 days ago | 2 days ago\n 4 | skip.rs       | File |          | 1.7 KB  | 2 days ago | 2 days ago\n 5 | str.rs        | File |          | 21.4 KB | 2 days ago | 2 days ago\n 6 | sum.rs        | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 7 | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n 8 | textview.rs   | File |          | 9.4 KB  | 2 days ago | 2 days ago\n 9 | tree.rs       | File |          | 3.0 KB  | 2 days ago | 2 days ago\n---+---------------+------+----------+---------+------------+------------\n\n> ls | sort-by name | nth 5\n--------+------+----------+---------+------------+------------\n name   | type | readonly | size    | accessed   | modified\n--------+------+----------+---------+------------+------------\n str.rs | File |          | 21.4 KB | 2 days ago | 2 days ago\n--------+------+----------+---------+------------+------------\n</code></pre></div><h2 id=\"obteniendo-datos-de-una-tabla\" tabindex=\"-1\"> Obteniendo datos de una tabla</h2>\n<p>Hasta ahora hemos trabajado con tablas reduciendo la tabla a solo lo que necesitamos. A veces es posible que queramos ir un paso mÃ¡s allÃ¡ y solo mirar los valores en las celdas en lugar the tomar una columna completa. Digamos, por ejemplo, que queramos obtener una lista de los nombres de los archivos. Para esto usamos el comando <code>get</code>:</p>\n<div><pre><code>> ls | get name\n---+---------------\n # | value\n---+---------------\n 0 | add.rs\n 1 | sum.rs\n 2 | inc.rs\n 3 | str.rs\n 4 | skip.rs\n 5 | textview.rs\n 6 | binaryview.rs\n 7 | edit.rs\n 8 | tree.rs\n 9 | sys.rs\n---+---------------\n</code></pre></div><p>Ahora tenemos los valores de cada nombre de los archivos.</p>\n<p>Puede parecerse al comando <code>select</code> que vimos previamente, probemos <code>select</code> para comparar los dos:</p>\n<div><pre><code>> ls | select name\n---+---------------\n # | name\n---+---------------\n 0 | add.rs\n 1 | sum.rs\n 2 | inc.rs\n 3 | str.rs\n 4 | skip.rs\n 5 | textview.rs\n 6 | binaryview.rs\n 7 | edit.rs\n 8 | tree.rs\n 9 | sys.rs\n---+---------------\n</code></pre></div><p>Â¡Se ven muy similares! Veamos si podemos explicar la diferencia entre estos dos comandos para aclarar:</p>\n<ul>\n<li><code>select</code> - crea una tabla donde incluye Ãºnicamente las columnas indicadas</li>\n<li><code>get</code> - devuelve los valores dentro de la columna indicada</li>\n</ul>\n<p>La manera de distinguirlas mirando la tabla de forma caracterÃ­stica es con el nombre de columna <code>value</code> que nos permite saber que serÃ¡ una lista de valores con la que podemos trabajar.</p>\n<p>El comando <code>get</code> puede ir mÃ¡s allÃ¡ y tomar una ruta para datos mÃ¡s profundos en la tabla. Esto simplifica trabajar con datos mÃ¡s complejos como las estructuras que podrÃ­as encontrar en archivos .json.</p>\n<h2 id=\"cambiando-datos-de-una-tabla\" tabindex=\"-1\"> Cambiando datos de una tabla</h2>\n<p>AdemÃ¡s de seleccionar datos de una tabla, tambiÃ©n podemos actualizar lo que contiene una tabla. Es posible que queramos agregar nuevas columnas o editar el contenido de una celda. En Nu, en lugar la misma tabla, cada uno de los comandos en la secciÃ³n devolvera una nueva tabla en la tuberÃ­a.</p>\n<h3 id=\"agregando-una-nueva-columna\" tabindex=\"-1\"> Agregando una nueva columna</h3>\n<p>Podemos utilizar el comando <code>add</code> para agregar una nueva columna a la tabla. Veamos un ejemplo:</p>\n<div><pre><code>> open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n</code></pre></div><p>Agreguemos una columna llamada &quot;next_edition&quot; con el valor 2021:</p>\n<div><pre><code>> open rustfmt.toml | add next_edition 2021\n---------+--------------\n edition | next_edition\n---------+--------------\n 2018    | 2021\n---------+--------------\n</code></pre></div><p>Observa que si abrimos el archivo original el contenido permanece igual:</p>\n<div><pre><code>> open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n</code></pre></div><p>Los cambios en Nu son cambios funcionales, lo que significa que funcionan en los valores mismos en vez de causar cambios permanentes. Esto nos permite realizar diferentes tipos de trabajo en nuestra tuberÃ­a hasta que estemos listos para grabar los resultados con cualquier cambio que nos gustarÃ­a si asÃ­ decidimos. AquÃ­ podrÃ­amos grabar los resultados usando el comando <code>save</code>:</p>\n<div><pre><code>> open rustfmt.toml | add next_edition 2021 | save rustfmt2.toml\n/home/jonathan/Source/nushell(master)> open rustfmt2.toml\n---------+--------------\n edition | next_edition\n---------+--------------\n 2018    | 2021\n---------+--------------\n</code></pre></div><h3 id=\"editando-una-columna\" tabindex=\"-1\"> Editando una columna</h3>\n<p>Similarmente al comando <code>add</code>, tambiÃ©n podemos usar el comando <code>edit</code> para cambiar el contenido de una columna a un nuevo valor. Abramos el mismo archivo para verlo en acciÃ³n:</p>\n<div><pre><code>open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n</code></pre></div><p>y ahora, actualizemos la ediciÃ³n y que apunte a la siguiente ediciÃ³n que esperamos soportar:</p>\n<div><pre><code>> open rustfmt.toml | edit edition 2021\n---------\n edition\n---------\n 2021\n---------\n</code></pre></div><h3 id=\"incrementando-valores\" tabindex=\"-1\"> Incrementando valores</h3>\n<p>Hay un comando mÃ¡s en Nu que nos ayudarÃ¡ a trabajar con nÃºmeros y versiones: <code>inc</code>.</p>\n<div><pre><code>> open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n> open rustfmt.toml | inc edition\n---------\n edition\n---------\n 2019\n---------\n</code></pre></div><p>Como el valor en &quot;edition&quot; es un nÃºmero, podemos usar <code>inc</code> para actualizarlo. <code>inc</code> realmente brilla cuando trabajamos con versiones:</p>\n<div><pre><code>> open Cargo.toml | get package.version\n0.1.3\n> open Cargo.toml | inc package.version --minor | get package.version\n0.2.0\n</code></pre></div><p>Cuando trabajamos con versiones podemos usar banderas e indicar cÃ³mo incrementar la versiÃ³n:</p>\n<ul>\n<li><strong>--major</strong> - incrementar major (0.1.3 -&gt; 1.0.0)</li>\n<li><strong>--minor</strong> - incrementar minor (0.1.3 -&gt; 0.2.0)</li>\n<li><strong>--patch</strong> - incrementar patch (0.1.3 -&gt; 0.1.4)</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.693Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Variables y Subexpresiones",
      "url": "www.nushell.sh/es/book/variables_y_subexpresiones.html",
      "id": "www.nushell.sh/es/book/variables_y_subexpresiones.html",
      "content_html": "<h1 id=\"variables-y-subexpresiones\" tabindex=\"-1\"> Variables y Subexpresiones</h1>\n<p>En Nushell hay dos tipos de expresiones de evaluaciÃ³n: variables y subexpresiones. Cuando lees expresiones que empiezan con el signo dÃ³lar (<code>$</code>) sabes que trabajas con una expresiÃ³n de evaluaciÃ³n. Esto indica que cuando Nushell toma el valor en esta posiciÃ³n, necesitarÃ¡ ejecutar un paso de evaluaciÃ³n para procesar la expresiÃ³n y posterioremente usar el valor del resultado. Ambas formas de expresiÃ³n de evaluaciÃ³n soportan un modo simple y una forma ruta (<code>path</code>) para trabajar con datos mÃ¡s complejos.</p>\n<h2 id=\"variables\" tabindex=\"-1\"> Variables</h2>\n<p>La variable es el mÃ¡s simple de ambas expresiones de evaluaciÃ³n. Durante la evaluaciÃ³n, una variable es remplazada for su valor.</p>\n<p>Si creamos una variable, podemos imprimir su contenido al usar <code>$</code> para referir a la misma:</p>\n<div><pre><code>> let mi-valor = 4\n> echo $mi-valor\n4\n</code></pre></div><h2 id=\"variables-rutas-paths\" tabindex=\"-1\"> Variables rutas (paths)</h2>\n<p>Una variable ruta funciona al llegar dentro del contenido de una variable, navegando columnas dentro de la misma para alcanzar un valor final. Supongamos que en vez de <code>4</code>, hayamos asignado una tabla como valor:</p>\n<div><pre><code>> let mi-valor = [[nombre]; [pruebausuario]]\n</code></pre></div><p>Podemos usar variables ruta para evaluar la variable <code>$mi-valor</code> y obtener el valor de la columna <code>nombre</code> con un solo paso:</p>\n<div><pre><code>> echo $mi-valor.nombre\npruebausuario\n</code></pre></div><h2 id=\"subexpresiones\" tabindex=\"-1\"> Subexpresiones</h2>\n<p>Siempre puedes evaluar subexpresiones y usar su resultado envolviendo la expresiÃ³n entre parÃ©ntesis <code>()</code>.</p>\n<p>Los parÃ©ntesis contienen una tuberÃ­a que se ejecutarÃ¡ hasta completar, y su valor final serÃ¡ usado. Por ejemplo, <code>(ls)</code> ejecutarÃ­a el comando <code>ls</code>, devolviendo como resultado la tabla y <code>(git branch --show-current)</code> ejecutarÃ¡ el comando externo git y devolver una cadena con el nombre de la rama actual. TambiÃ©n puedes usar parÃ©ntesis para ejecutar expresiones matemÃ¡ticas como <code>(2 + 3)</code>.</p>\n<p>Subexpresiones tambiÃ©n pueden ser tuberÃ­as y no solamente comandos individuales. Si desearamos una lista de nombres de archivos superiores a diez kilobytes, podemos utilizar subexpresiones para ejecutar una tuberÃ­a y asignar el resultado a una variable:</p>\n<div><pre><code>> let nombres-de-archivos-grandes = (ls | where size > 10kb)\n> echo $nombres-de-archivos-grandes\nâ”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n # â”‚    name    â”‚ type â”‚   size   â”‚   modified\nâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n 0 â”‚ Cargo.lock â”‚ File â”‚ 155.3 KB â”‚ 17 hours ago\n 1 â”‚ README.md  â”‚ File â”‚  15.9 KB â”‚ 17 hours ago\nâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n</code></pre></div><h2 id=\"subexpresiones-y-rutas\" tabindex=\"-1\"> Subexpresiones y rutas</h2>\n<p>Subexpresiones tambiÃ©n soportan rutas. Por ejemplo, supongamos que queremos una lista de nombres de archivos en el directorio actual. Una manera de hacerlo es con una tuberÃ­a:</p>\n<div><pre><code>> ls | get name\n</code></pre></div><p>Pero tambiÃ©n podemos hacer una acciÃ³n similar con un solo paso usando una subexpresiÃ³n de ruta:</p>\n<div><pre><code>> echo (ls).name\n</code></pre></div><p>Todo depende de las necesidades del cÃ³digo o estilo particular que trabaje mejor para ti.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Ãndice",
      "url": "www.nushell.sh/es/contributor-book/",
      "id": "www.nushell.sh/es/contributor-book/",
      "content_html": "<h1 id=\"indice\" tabindex=\"-1\"> Ãndice</h1>\n<ul>\n<li><a href=\"/es/contributor-book/introduccion.html\">IntroducciÃ³n</a> - Una introducciÃ³n al libro para contribuyentes</li>\n<li><a href=\"/es/contributor-book/filosofia.html\">FilosofÃ­a</a> - La filosofÃ­a del diseÃ±o central</li>\n<li><a href=\"/es/contributor-book/valores.html\">Valores</a> - Los valores (tipos de datos)</li>\n<li><a href=\"/es/contributor-book/comandos.html\">Comandos</a> - CÃ³mo funcionan los comandos</li>\n<li>Streams - CÃ³mo funcionan los streams</li>\n<li><a href=\"/es/contributor-book/metadatos.html\">Metadatos</a> - El sistema de metadatos</li>\n<li>Plugins - CÃ³mo escribir plugins</li>\n<li>Shells - CÃ³mo funciona el sistema de shell</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Comandos",
      "url": "www.nushell.sh/es/contributor-book/comandos.html",
      "id": "www.nushell.sh/es/contributor-book/comandos.html",
      "content_html": "<h1 id=\"comandos\" tabindex=\"-1\"> Comandos</h1>\n<p>Los comandos son los bloques de construcciÃ³n para las tuberÃ­as (pipeline) en Nu. Realizan la acciÃ³n de la tuberÃ­a, ya sea creando datos, cambiando datos mientras fluye desde entradas y salidas, o viendo los datos una vez que salen de la tuberÃ­a. Hay dos tipos de comandos: comandos internos, son aquellos contruÃ­dos para ejecuciÃ³n interna de Nu, y comandos externos, comandos que se encuentra fuera de Nu y se comunican con <code>stdin</code> / <code>stdout</code> de estilo Unix estÃ¡ndar.</p>\n<h2 id=\"comandos-internos\" tabindex=\"-1\"> Comandos internos</h2>\n<p>Todos los comandos dentro de Nu, incluyendo complementos (plugins), son comandos internos. Comandos internos se comunican entre ellos usando streams de <code>Tagged&lt;Value&gt;</code> y ShellError (TODO: Enlace a tipos de datos)</p>\n<h3 id=\"firma\" tabindex=\"-1\"> Firma</h3>\n<p>Los comandos utilizan verificaciÃ³n de tipado ligero para garantizar que los argumentos pasados puedan ser manejados correctamente. Para habilitar esto, cada comando proporciona una firma que le dice a Nu:</p>\n<ul>\n<li>El nombre del comando</li>\n<li>Los argumentos posicionales (ej, en <code>start x y</code> la <code>x</code> y la <code>y</code> son argumentos posicionales)</li>\n<li>Si el comando</li>\n<li>Si el comando toma un nÃºmero adicional ilimitado de argumentos posicionales (ej, <code>start a1 a2 a3 ... a99 a100</code>)</li>\n<li>Los argumentos nombrados (ej, <code>start --now</code>)</li>\n<li>Si el comando es un filtro o sink</li>\n</ul>\n<p>Con esta informaciÃ³n, se puede verificar problemas potenciales antes de la ejecuciÃ³n de la tuberÃ­a.</p>\n<h2 id=\"comandos-externos\" tabindex=\"-1\"> Comandos externos</h2>\n<p>Un comando externo es cualquier comando que no forma parte de los comandos o complementos (plugins) integrados de Nu. Si se llama un comando que Nu desconoce, llamarÃ¡ al entorno subyacente con los argumentos suministrados para intentar el comando como un programa externo.</p>\n<h2 id=\"comunicacion-entre-comandos-internos-y-externos\" tabindex=\"-1\"> ComunicaciÃ³n entre comandos internos y externos</h2>\n<h3 id=\"interno-a-interno\" tabindex=\"-1\"> Interno a interno</h3>\n<p>Los comandos internos se comunican entre ellos usando el stream completo que proporciona Nu, que incluye todos los tipos de archivos integrados. Esto incluye la comunicaciÃ³n entre comandos internos y complementos (en ambas direcciones).</p>\n<h3 id=\"intero-a-externo\" tabindex=\"-1\"> Intero a externo</h3>\n<p>Los comandos internos que envÃ­an texto a comandos externos necesitan tener cadenas de texto preparadas con anticipaciÃ³n. Si un objeto es enviado directamente a un comando externo, se considerarÃ¡ como un error ya que no hay forma de inferir cÃ³mo los datos estructurados serÃ¡n representados para el programa externo. Se espera que el usuario se limite a una simple celda de datos o usar uno de los convertidores (como <code>to-json</code>) para convertir la tabla en una representaciÃ³n de cadena.</p>\n<p>El comando externo se abre para que si entrada estÃ¡ndar <code>stdin</code> sea redireccionada, de modo que los datos se puedan enviar a Ã©l.</p>\n<h3 id=\"externo-a-interno\" tabindex=\"-1\"> Externo a interno</h3>\n<p>Los comandos externos envÃ­an una serie de cadenas a travÃ©s de su salida estÃ¡ndar <code>stdout</code>. Estas cadenas se leen en la tuberÃ­a y se ponen a disposiciÃ³n al comando interno que sigue en la tuberÃ­a, o se muestran al usuario si el comando externo es el Ãºltimo paso en la tuberÃ­a.</p>\n<h3 id=\"externo-a-externo\" tabindex=\"-1\"> Externo a externo</h3>\n<p>Los comandos externos se comunican entre sÃ­ a travÃ©s de estÃ¡ndar <code>stdin</code>/<code>stdout</code>. Como Nu detectarÃ¡ esta situaciÃ³n, redirigirÃ¡ la salida estÃ¡ndar <code>stdout</code> del primer comando a la entrada estÃ¡ndar <code>stdin</code> del siguiente comando externo. De esta forma, se mantiene el comportamiento esperado de una tuberÃ­a de shell entre comandos externos.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Filosofia",
      "url": "www.nushell.sh/es/contributor-book/filosofia.html",
      "id": "www.nushell.sh/es/contributor-book/filosofia.html",
      "content_html": "<h1 id=\"filosofia\" tabindex=\"-1\"> Filosofia</h1>\n<h2 id=\"valores-fundamentales\" tabindex=\"-1\"> Valores Fundamentales</h2>\n<p>El valor central de Nu es que trabajar en un shell debe ser divertido. Para esto, creemos que:</p>\n<ul>\n<li>Una shell moderna debe ser diseÃ±ada para usabilidad y ergonomÃ­a. <strong>Por encima de todo, Nu deberÃ­a ser divertido de usar.</strong></li>\n<li>DeberÃ­a proporcionar buenos mensajes informativos de errores cuando un comando no finalizarÃ¡ correctamente. Esto es de vital importancia. Un shell divertido da mensajes de errores <strong>claros y procesables</strong></li>\n<li>Debe construirse en torno al uso casual, ya que esta es la mayorÃ­a del uso en una shell, incluso para usuarios con experiencia. Construyendo una shell que sea <strong>divertido para uso casual se traduce a una shell divertida para todos</strong>.</li>\n<li>Nu soporta experimentaciÃ³n y <strong>crecer ideas de experimentos a programas</strong>. La habilidad de evolucionar ideas desde lÃ­neas simples, scripts, y posteriormente a programas es un papel clave que se desempeÃ±a en una shell. Para respaldar esto, Nu se basa en la idea de comandos componibles que funcionan en un conjutos compartido de tipos de datos.</li>\n</ul>\n<h2 id=\"no-metas\" tabindex=\"-1\"> No metas</h2>\n<ul>\n<li><em>Rendimiento Ã³ptimo</em>. Si bien nos preocupa rendimiento, el enfoque en el rendimiento debe estar al servicio de hacer que Nu sea mÃ¡s usable y agradable de usar. El mejor rendimiento en micro-puntos de referencia no es un objetivo.</li>\n<li><em>Estricto</em>. Queremos ayudar a los usuarios a escribir buenos scripts, pero centrÃ¡ndonos en que dichos scripts sean correctos con buenos errores y buena documentaciÃ³n.</li>\n<li><em>Cumplimiento-POSIX</em>. Nu se optimiza intencionalmente para una experiencia placentera en vez de igualar cÃ³mo programas de lÃ­nea de comandos funcionan de una manera POSIX-compliant. Es importante poder interoperar entre comandos de Nu y comandos externos, pero mantener compatibilidad estricta no es una meta.</li>\n<li><em>AdhesiÃ³n de paradigma</em>. Nu mira el espacio de shells flexiblemente, y presta buenas ideas de programaciÃ³n funcional, programaciÃ³n de sistemas, orientaciÃ³n a objetos, y mÃ¡s donde sea posible. Seguir algun paradigma en particular de manera rÃ­gida no sirve para los objetivos del proyecto Nu.</li>\n</ul>\n<h2 id=\"diseno-basico\" tabindex=\"-1\"> DiseÃ±o BÃ¡sico</h2>\n<p>El diseÃ±o central de Nu es el modelo de datos. Comandos siguen en gran medida en el servicio para facilitar la creaciÃ³n de datos, trabajar con datos, y ver datos. Una de las piezas visibles de este trabajo es la canalizaciÃ³n a travÃ©s de la tuberÃ­a, que se basa en gran medida en las ideas originales de Unix de conectar comandos simples en comandos mÃ¡s complejos. Nu toma esta filosofÃ­a de Unix y la extiende desde solo cÃ¡denas de texto al mÃ¡s amplio conjuntos de datos que es mÃ¡s comÃºn en lenguajes modernos de programaciÃ³n.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "IntroducciÃ³n",
      "url": "www.nushell.sh/es/contributor-book/introduccion.html",
      "id": "www.nushell.sh/es/contributor-book/introduccion.html",
      "content_html": "<h1 id=\"introduccion\" tabindex=\"-1\"> IntroducciÃ³n</h1>\n<p>Hola y bienvenido al manual de Nushell para contribuyentes. Nushell, o Nu como se lo llama a menudo, es un shell moderno escrito en Rust. Para mÃ¡s informaciÃ³n sobre Nu y cÃ³mo usarlo puedes aprenderlo en <a href=\"/es/book\">El libro Nu</a>. En este manual, veremos cÃ³mo contribuir al proyecto Nu, cÃ³mo estÃ¡ organizado el cÃ³digo, y los conceptos centrales detrÃ¡s de su diseÃ±o.</p>\n<p>Contribuir a Nu requerirÃ¡ al menos algo de experiencia bÃ¡sica en programaciÃ³n, y es Ãºtil tener algo de experiencia con Rust. Dicho esto, hemos tenido personas que han contribuÃ­do a Nu sin antes haber escrito una lÃ­nea de Rust antes de que escribieran su primera contribuciÃ³n. Si te interesa contribuir, hay una comunidad creciente de personas con deseos de ayudarte a tener Ã©xito.</p>\n<p>Este manual estÃ¡ dividido en tres partes:</p>\n<ol>\n<li>El diseÃ±o de Nu</li>\n<li>La implementaciÃ³n de Nu</li>\n<li>Mejores prÃ¡cticas de cÃ³digo en Nu</li>\n</ol>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Metadatos",
      "url": "www.nushell.sh/es/contributor-book/metadatos.html",
      "id": "www.nushell.sh/es/contributor-book/metadatos.html",
      "content_html": "<h1 id=\"metadatos\" tabindex=\"-1\"> Metadatos</h1>\n<p>Todos los valores que fluyen dentro y fuera de los comandos en Nu estÃ¡n etiquetadas con metadatos. Lo encontrarÃ¡s comÃºnmente alrededor del cÃ³digo como <code>Tagged&lt;Value&gt;</code></p>\n<p>Aunque los metadatos que se rastrean sigue en sus primeros dÃ­as, esperamos expandir esto a medida que Nu madure.</p>\n<p>Actualmente, hay dos piezas de metadatos rastreados en cada valor:</p>\n<h2 id=\"origin\" tabindex=\"-1\"> Origin</h2>\n<p>Origin representa la ubicaciÃ³n de donde vino originalmente el valor. Si el valor fue cargado desde un archivo, serÃ¡ el nombre del archivo. Si fue cargado desde una Url, serea la Url, y asÃ­ sucesivamente.</p>\n<p>Para ahorrar espacio y mantener los metadatos Copy(copiables), el origen se guarda como un UUID. Este identificador apunta a una tabla de bÃºsqueda donde el UUID se puede traducir al origen completo.</p>\n<h2 id=\"span\" tabindex=\"-1\"> Span</h2>\n<p>Span(tramos) es la ubicaciÃ³n de inicio y fin del valor donde fue creado o referenciado en la lÃ­nea de comandos. Estas se ven comÃºnmente representadas como el subrayado debajo de un mensaje de error.</p>\n<p>Mientras los spans(tramos) de lenguajes de programaciÃ³n tradicionalmente tambiÃ©n llevan el archivo del que proviene el tramo, aquÃ­ asumimos que el tramo siempre abarca un valor referenciado en la lÃ­nea de comandos en lugar de un archivo de cÃ³digo fuente. A medida que Nu tenga la capacidad de ejecutar sus propios archivos de cÃ³digo fuente, esto probablemente tendrÃ¡ que ser revisado.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Valores",
      "url": "www.nushell.sh/es/contributor-book/valores.html",
      "id": "www.nushell.sh/es/contributor-book/valores.html",
      "content_html": "<h1 id=\"valores\" tabindex=\"-1\"> Valores</h1>\n<p>Un Value es el tipo de dato de estructura bÃ¡sica en Nu.</p>\n<div><pre><code><span>pub</span> <span>struct</span> <span>Value</span> <span>{</span>\n    <span>pub</span> value<span>:</span> <span>UntaggedValue</span><span>,</span>\n    <span>pub</span> tag<span>:</span> <span>Tag</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Donde el campo <code>value</code> es cualquier tipo de valor <code>UntaggedValue</code> dado y el campo <code>tag</code> contiene <a href=\"/es/contributor-book/metadatos.html\">metadatos</a> asociado con Ã©l.</p>\n<p>Un <code>UntaggedValue</code> cubre los siguientes tipos de valores:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>UntaggedValue</span> <span>{</span>\n    <span>Primitive</span><span>(</span><span>Primitive</span><span>)</span><span>,</span>\n    <span>Row</span><span>(</span><span>Dictionary</span><span>)</span><span>,</span>\n    <span>Table</span><span>(</span><span>Vec</span><span>&lt;</span><span>Value</span><span>></span><span>)</span><span>,</span>\n\n    <span>Error</span><span>(</span><span>ShellError</span><span>)</span><span>,</span>\n\n    <span>Block</span><span>(</span><span>Evaluate</span><span>)</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Donde <code>Primitive</code> es:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>Primitive</span> <span>{</span>\n    <span>Nothing</span><span>,</span>\n    <span>Int</span><span>(</span><span>BigInt</span><span>)</span><span>,</span>\n    <span>Decimal</span><span>(</span><span>BigDecimal</span><span>)</span><span>,</span>\n    <span>Bytes</span><span>(</span><span>u64</span><span>)</span><span>,</span>\n    <span>String</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>Line</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>ColumnPath</span><span>(</span><span>ColumnPath</span><span>)</span><span>,</span>\n    <span>Pattern</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>Boolean</span><span>(</span><span>bool</span><span>)</span><span>,</span>\n    <span>Date</span><span>(</span><span>DateTime</span><span>&lt;</span><span>Utc</span><span>></span><span>)</span><span>,</span>\n    <span>Duration</span><span>(</span><span>u64</span><span>)</span><span>,</span>\n    <span>Range</span><span>(</span><span>Box</span><span>&lt;</span><span>Range</span><span>></span><span>)</span><span>,</span>\n    <span>Path</span><span>(</span><span>PathBuf</span><span>)</span><span>,</span>\n    <span>Binary</span><span>(</span><span>Vec</span><span>&lt;</span><span>u8</span><span>></span><span>)</span><span>,</span>\n\n    <span>// Stream markers (used as bookend markers rather than actual values)</span>\n    <span>BeginningOfStream</span><span>,</span>\n    <span>EndOfStream</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Revisemos al revÃ©s para ver cÃ³mo se construyen tipos de datos completos a partir de los primitivos:</p>\n<h2 id=\"primitivos-primitive\" tabindex=\"-1\"> Primitivos (<code>Primitive</code>)</h2>\n<p>El tipo de dato <code>Primitive</code> es el tipo fundamental en Nu. Mientras hay similaridades a tipos de datos fundamentales de lenguajes de programaciÃ³n, hay algunas diferencias debido a las capacidades en la shell de Nu.</p>\n<p>Nu viene con dos tipos de nÃºmeros 'grandes': <code>BigInt</code> para enteros y <code>BigDecimal</code> para nÃºmeros decimales. Esto permite en el futuro lograr operaciones matemÃ¡ticas y mantener precisiÃ³n mÃ¡s tiempo en Nu.</p>\n<p>Otros tipo de datos, quizÃ¡s un poco diferentes a la norma:</p>\n<ul>\n<li><code>Nothing</code> = representa un valor vacÃ­o</li>\n<li><code>Bytes(u64)</code> = tamaÃ±os de archivo en nÃºmeros de bytes</li>\n<li><code>Line(String)</code> = valor de cadena con un final de retorno de carro implÃ­cito (o cr / lf)</li>\n<li><code>ColumnPath(ColumnPath)</code> = rutas para extraer valores de las tablas</li>\n<li><code>Pattern(string)</code> = un patrÃ³n glob (como <code>nu*</code> en <code>ls nu*</code>)</li>\n<li><code>Duration(u64)</code> = representa duraciÃ³n en segundos (como <code>1hr</code> en <code>ls | where modified &lt; 1hr</code> )</li>\n<li><code>Range(Box&lt;Range&gt;)</code> = rangos (como <code>0..2</code> en <code>ls | range 0..2</code>)</li>\n<li><code>Path(PathBuf)</code> = una ruta de archivo</li>\n<li><code>Binary(Vec&lt;u8&gt;)</code> = un arreglo de bytes</li>\n<li><code>BeginningOfStream</code> = un marcador para denotar el inicio de un stream</li>\n<li><code>EndOfStream</code> = un marador para denotar el fin de un stream</li>\n</ul>\n<h2 id=\"untaggedvalue\" tabindex=\"-1\"> UntaggedValue</h2>\n<p>AdemÃ¡s de los tipos primitivos, Nu admite tipos de datos agregados. Colectivamente, estos tipos agregados se llaman <code>UntaggedValue</code>s.</p>\n<p>Actualmente, Nu admite 5 tipos de valor <code>UntaggedValue</code>: <code>Row</code>, <code>Table</code>, <code>Block</code>, <code>Primitive</code>, y <code>Error</code>.</p>\n<h3 id=\"tablas-y-filas-table-y-row\" tabindex=\"-1\"> Tablas y Filas (<code>Table</code> y <code>Row</code>)</h3>\n<p>Nu utiliza un conjunto de tÃ©rminos que coinciden un poco mÃ¡s con las hojas de cÃ¡lculo. En lugar de tener listas de objetos, Nu tiene una tabla que contiene filas. Cada fila contiene los nombres de columna y sus valores correspondientes.</p>\n<h3 id=\"bloques-block\" tabindex=\"-1\"> Bloques (<code>Block</code>)</h3>\n<p>Bloques representa cÃ³digo listo para ser ejecutado por el evaluador. Un ejemplo de esto es la condiciÃ³n <code>where {$it &gt; 10}</code>.</p>\n<h3 id=\"errores-error\" tabindex=\"-1\"> Errores (<code>Error</code>)</h3>\n<p>Representa los errores que pueden ocurrir cuando se ejecutan los comandos en la tuberÃ­a.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    }
  ]
}